# -*- coding: UTF-8 -*-
#
# generated by wxGlade 0.8.0b3 on Tue Jan 30 13:49:27 2018
#

import timeit
import numpy as np
from gridop import *


###############################################################
# Ertel Potential vorticity


def get_pv(run, z=None, tindex=None, typ='ijk'):
    """
    #
    #   epv    - The ertel potential vorticity with respect to property 'lambda'
    #
    #                                       [ curl(u) + f ]
    #   -  epv is given by:           EPV = --------------- . del(lambda)
    #                                            rho
    #
    #   -  pvi,pvj,pvk - the x, y, and z components of the potential vorticity.
    #
    #   -  Ertel PV is calculated on horizontal rho-points, vertical w-points.
    #
    #
    #   tindex   - The time index at which to calculate the potential vorticity.
    #   depth    - depth
    #
    # Adapted from rob hetland.
    #
    """

    # Grid parameters
    ds=run.ds.isel(t=tindex) if tindex is not None else run.ds
    grid = ds.attrs['xgcm-Grid']

    pm = ds['dx_r']
    pn = ds['dy_r']
    f = ds['f']
    rho0 = run.parameters['rho0']
    
    # 3D variables
    z=z if z is not None else get_z(ds, tindex=tindex)
    dz = grid.diff(z,'s')
    u = ds['u'].persist()
    v = ds['v'].persist()
    w = ds['w'].persist()

    try:
        rho = ds['rho'].persist()
    except Exception:
        print('rho not in history file')
        return

    if 'k' in typ:
        #
        #
        #  Ertel potential vorticity, term 1: [f + (dv/dx - du/dy)]*drho/dz
        #
        # Compute d(v)/d(xi) at PSI-points.
        #
        dxm1 = rho2psi(pm, ds)
        dvdxi = grid.diff(v,'lon') * dxm1
        #
        #  Compute d(u)/d(eta) at PSI-points.
        #
        dym1 = rho2psi(pn, ds)
        dudeta = grid.diff(u,'lat') * dym1
        #
        #  Compute d(rho)/d(z) at horizontal RHO-points and vertical W-points
        #
        drhodz = grid.diff(rho,'s') / dz
        #
        #  Compute Ertel potential vorticity <k hat> at horizontal RHO-points and
        #  vertical W-points. 
        omega = dvdxi - dudeta
        omega = f + psi2rho(omega,ds)
        pvk = rho2w(omega,ds) * drhodz
    else:
        pvk = 0.

    if 'i' in typ:
        #
        #
        #  Ertel potential vorticity, term 2: (dw/dy - dv/dz)*(drho/dx)
        #
        #  Compute d(w)/d(y) at horizontal V-points and vertical RHO-points
        #
        dym1 = rho2v(pn, ds)
        dwdy = grid.diff(w,'lat') * dym1
        #
        #  Compute d(v)/d(z) at horizontal V-points and vertical W-points
        #
        dz_v = rho2v(dz, ds)
        dvdz = grid.diff(v,'s') / dz_v
        #
        #  Compute d(rho)/d(xi) at horizontal U-points and vertical RHO-points
        #
        dxm1 = rho2u(pm, ds)
        drhodx = grid.diff(rho,'lon') * dxm1
        #
        #  Add in term 2 contribution to Ertel potential vorticity at horizontal RHO-points and
        #  vertical W-points.
        #
        pvi = ( rho2w(v2rho(dwdy,ds),ds) - v2rho(dvdz,ds) ) * rho2w(u2rho(drhodx,ds),ds)
    else:
        pvi = 0.

    if 'j' in typ:
        #
        #
        #  Ertel potential vorticity, term 3: (du/dz - dw/dx)*(drho/dy)
        #
        #  Compute d(u)/d(z) at horizontal U-points and vertical W-points
        #
        dz_u = rho2u(dz, ds)
        dudz = grid.diff(u,'s') / dz_u
        #
        #  Compute d(w)/d(x) at horizontal U-points and vertical RHO-points
        #
        dxm1 = rho2u(pm, ds)
        dwdx = grid.diff(w,'lon') * dxm1
        #
        #  Compute d(rho)/d(eta) at horizontal V-points and vertical RHO-points
        #
        dym1 = rho2v(pn, ds)
        drhodeta = grid.diff(rho,'lat') * dym1
        #
        #  Add in term 3 contribution to Ertel potential vorticity at horizontal RHO-points and
        #  vertical W-points..
        #
        pvj = ( u2rho(dudz,ds) - rho2w(u2rho(dwdx,ds),ds) ) * rho2w(v2rho(drhodeta,ds),ds)
    else:
        pvj = 0.

    #
    #
    # Sum potential vorticity components, and divide by rho0
    #
    pvi = pvi / rho0
    pvj = pvj / rho0
    pvk = pvk / rho0
    pv = pvi + pvj + pvk

    z_w = get_z(ds, vgrid='w')
    pv = pv.assign_coords(coords={"z":z_w})
    
    return pv.squeeze()
    #

###############################################################
# Zeta_k term


def get_zetak(run, tindex=None):
    """
    #   -  zetak is given by:      (dv/dx - du/dy)/f
    #
    #   -  zetak is calculated at RHO-points
    #
    #
    #   tindex   - The time index at which to calculate zetak.
    #
    # Adapted from rob hetland.
    #
    """
    
    # Grid parameters
    ds=run.ds.isel(t=tindex) if tindex is not None else run.ds
    grid = ds.attrs['xgcm-Grid']

    pm = ds['dx_r']
    pn = ds['dy_r']
    f = ds['f']
    
    # 3D variables
    u = ds['u'].compute()
    v = ds['v'].compute()    
     
    # Ertel potential vorticity, term 1: (dv/dx - du/dy)/f
    
    # Compute d(v)/d(xi) at PSI-points. 
    dxm1 = rho2psi(pm, ds)
    dvdxi = grid.diff(v,'lon') * dxm1

    
    #  Compute d(u)/d(eta) at PSI-points.
    dym1 = rho2psi(pn, ds)
    dudeta = grid.diff(u,'lat') * dym1
    
    #  Compute Ertel potential vorticity <k hat> at horizontal RHO-points and
    #  vertical RHO-points.
    omega = psi2rho(dvdxi - dudeta, ds)

    z_r = get_z(ds, vgrid='r')
    omega = omega.assign_coords(coords={"z":z_r})

    return (omega/f).squeeze()

###############################################################
# dtdz term


def get_dtdz(run, z=None, tindex=None):
    """
    #   -  dtdz is given by:      dT/dz
    #
    #   -  zetak is calculated at w-points
    #
    #
    #   tindex   - The time index at which to calculate dtdz.
    #
    # Adapted from rob hetland.
    #
    """

    # Grid parameters
    ds=run.ds.isel(t=tindex) if tindex is not None else run.ds
    grid = ds.attrs['xgcm-Grid']

    # 3D variables
    z=z if z is not None else get_z(ds, tindex=tindex)
    dz = grid.diff(z,'s')
    t = ds['temp']

    dtdz = (grid.diff(t,'s')/dz).squeeze()
    add_coords(ds,dtdz, ['lon_r','lat_r'])
    z_w = get_z(ds, vgrid='w')
    dtdz = dtdz.assign_coords(coords={"z":z_w})
    return dtdz

###############################################################
# Richardson Number


def get_richardson(run, z=None, tindex=None):
    """
      -  Ri is given by:      N²/((du/dz)² - (dv/dz)²)
         with N = sqrt(-g/rho0 * drho/dz)
    
      -  Ri is calculated at RHO-points and w level
    
    
      tindex   - The time index at which to calculate the potential vorticity.
      depth    - depth
    
    """

    # Grid parameters
    ds=run.ds.isel(t=tindex) if tindex is not None else run.ds
    grid = ds.attrs['xgcm-Grid']
    g = run.parameters['g']
    rho0 = run.parameters['rho0']
    
    # 3D variables
    z=z if z is not None else get_z(ds, tindex=tindex)
    dz = grid.diff(z,'s')

    rho = ds['rho'].persist()
    u = ds['u'].persist()
    v = ds['v'].persist()
    
    drhodz = (grid.diff(rho,'s')/dz).squeeze()
    N2 = (-g / rho0) * (drhodz)

    dz_u = rho2u(dz,ds)
    dudz = (grid.diff(u,'s')/dz_u).squeeze()
    dz_v = rho2v(dz,ds)
    dvdz = (grid.diff(v,'s')/dz_v).squeeze()

    Ri = xr.ufuncs.log10(N2 / (u2rho(dudz,ds)**2 +  v2rho(dvdz,ds)**2)).squeeze()

    z_w = get_z(ds, vgrid='w')
    Ri = Ri.assign_coords(coords={"z":z_w})

    return(Ri)

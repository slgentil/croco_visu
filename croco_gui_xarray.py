# -*- coding: UTF-8 -*-
#
# generated by wxGlade 0.8.0b3 on Tue Jan 30 13:49:27 2018
#

import sys
import os
from   shutil import copyfile
import wx
import time
from datetime import datetime
import xarray as xr
import numpy as np
from numpy.matlib import repmat
import numpy.ma as ma
import scipy.io
import netCDF4 as netcdf
import matplotlib.pyplot as plt
# import matplotlib
# matplotlib.use('WXAgg')
from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas
import matplotlib as mpl
from matplotlib.figure import Figure
from matplotlib import colors
from matplotlib import animation
from matplotlib.widgets  import RectangleSelector
from CrocoXarray import Croco
from myplot import plotCurv, mypcolor

wildcard = "Netcdf Files (*.nc)|*.nc"
# figsize = [10,9]
figsize = [6,5]

# begin wxGlade: dependencies
# end wxGlade

# begin wxGlade: extracode
# end wxGlade

########################################################################

class SectionFrame(wx.Frame):
    """ 
    Window class to plot longitude and latitude sections.
    The window contains a canvas to plot, several buttons (animation, zoom in, zoom out, 
    print and reset color) and text control (start time and end time for animation, 
    min and max color for the colorbar)

    Attributes:
    croco : croco instance to study
    variableName : Name of the variable to plot in the canvas
    variable : 3D dataarray (x,y,t) of the variable to plot
    x : numpy array of x coordinates
    y : numpy array of y coordinates
    typSection: type of slice XZ or YZ
    sliceCoord: coordinate of the slice (latitude for XZ, latitude for YZ)
    timeIndex: current time index to plot
    """

    def __init__(self, croco=None, variableName = None, variable=None, x=None, y=None, \
        typSection=None , sliceCoord = None, timeIndex=None):
        """ return a SectioFrame instance """

        # Create the window
        wx.Frame.__init__(self, None, wx.ID_ANY, title='Section')

        # Now create the Panel to put the other controls on.
        self.panel = wx.Panel(self, wx.ID_ANY)

        # and a few controls
        self.figure = Figure()
        self.axes = self.figure.add_axes([0,0,1,1])
        self.canvas = FigureCanvas(self.panel, -1, self.figure)

        self.TimeLabel = wx.StaticText(self.panel,-1,label="Time",style = wx.ALIGN_CENTER)
        self.TimeTxt = wx.TextCtrl(self.panel, wx.ID_ANY, " ", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.ZoomInBtn = wx.Button(self.panel, wx.ID_ANY, "Zoom In")
        self.ZoomOutBtn = wx.Button(self.panel, wx.ID_ANY, "Zoom Out")
        self.PrintBtn = wx.Button(self.panel, wx.ID_ANY, "Print")

        self.AnimationBtn = wx.Button(self.panel, wx.ID_ANY, "Animation")
        self.startTimeTxt = wx.TextCtrl(self.panel, wx.ID_ANY, "1", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.endTimeTxt = wx.TextCtrl(self.panel, wx.ID_ANY, "1", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.SaveBtn = wx.Button(self.panel, wx.ID_ANY, "Save")
        
        self.ResetColorBtn = wx.Button(self.panel, wx.ID_ANY, "Reset Color")
        self.MinColorTxt = wx.TextCtrl(self.panel, wx.ID_ANY, "Min Color", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.MaxColorTxt = wx.TextCtrl(self.panel, wx.ID_ANY, "Max Color", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)

        # bind the menu event to an event handler
        self.canvas.mpl_connect('button_press_event', self.onFigureClick)
        self.AnimationBtn.Bind(wx.EVT_BUTTON, self.onAnimationBtn)
        self.startTimeTxt.Bind(wx.EVT_TEXT_ENTER, self.onstartTimeTxt)
        self.endTimeTxt.Bind(wx.EVT_TEXT_ENTER, self.onendTimeTxt)
        self.ZoomInBtn.Bind(wx.EVT_BUTTON, self.onZoomInBtn)
        self.ZoomOutBtn.Bind(wx.EVT_BUTTON, self.onZoomOutBtn)
        self.PrintBtn.Bind(wx.EVT_BUTTON, self.onPrintBtn)
        self.ResetColorBtn.Bind(wx.EVT_BUTTON, self.onResetColorBtn)
        self.MinColorTxt.Bind(wx.EVT_TEXT_ENTER, self.onMinColorTxt)
        self.MaxColorTxt.Bind(wx.EVT_TEXT_ENTER, self.onMaxColorTxt)
        self.SaveBtn.Bind(wx.EVT_BUTTON, self.onSaveBtn)
        self.TimeTxt.Bind(wx.EVT_TEXT_ENTER, self.onTimeTxt)

        self.__do_layout()

        # Initialize the variables of the class
        self.croco = croco
        self.variable = variable
        self.x = x
        self.y = y
        self.variableName = variableName
        self.typSection = typSection
        self.sliceCoord = sliceCoord
        self.timeIndex = timeIndex
        if croco is not None:
            self.time = self.croco.wrapper._get_date(0)
            self.TimeTxt.SetValue(str(self.time))
        if typSection == "XZ":
            self.xlabel = "Longitude"
            self.ylabel = "Depth"
            self.slice = "Latitude"
        elif typSection == "YZ":
            self.xlabel = "Latitude"
            self.ylabel = "Depth"
            self.slice = "Longitude"
        if croco is not None:
            timeMin = self.croco.wrapper._get_date(0)
            timeMax = self.croco.wrapper._get_date(self.croco.wrapper.ntimes-1)
            self.startTimeTxt.SetValue(str(timeMin))
            self.startTime = timeMin
            self.startTimeIndex = 0
            self.endTimeTxt.SetValue(str(timeMax))
            self.endTime = timeMax
            self.endTimeIndex = self.croco.wrapper.ntimes -1

    def __do_layout(self):
        """
        Use a sizer to layout the controls, stacked vertically or horizontally
        """
        topSizer        = wx.BoxSizer(wx.VERTICAL)
        canvasSizer     = wx.BoxSizer(wx.VERTICAL)
        timeSizer       = wx.BoxSizer(wx.HORIZONTAL)
        buttonsSizer    = wx.BoxSizer(wx.HORIZONTAL)
        colorSizer      = wx.BoxSizer(wx.HORIZONTAL)

        canvasSizer.Add(self.canvas, 0, wx.ALL, 5)

        timeSizer.Add(self.TimeLabel,0, wx.ALL, 5)
        timeSizer.Add(self.TimeTxt,0, wx.ALL, 5)
        timeSizer.Add(self.ZoomInBtn,0, wx.ALL, 5)
        timeSizer.Add(self.ZoomOutBtn,0, wx.ALL, 5)
        timeSizer.Add(self.PrintBtn,0, wx.ALL, 5)

        buttonsSizer.Add(self.AnimationBtn,0, wx.ALL, 5)
        buttonsSizer.Add(self.startTimeTxt,0, wx.ALL, 5)
        buttonsSizer.Add(self.endTimeTxt,0, wx.ALL, 5)
        buttonsSizer.Add(self.SaveBtn,0, wx.ALL, 5)

        colorSizer.Add(self.ResetColorBtn, 0, wx.ALL, 5)
        colorSizer.Add(self.MinColorTxt, 0, wx.ALL, 5)
        colorSizer.Add(self.MaxColorTxt, 0, wx.ALL, 5)

        topSizer.Add(canvasSizer, 0, wx.CENTER)
        topSizer.Add(timeSizer, 0, wx.ALL|wx.EXPAND, 5)
        topSizer.Add(buttonsSizer, 0, wx.ALL|wx.EXPAND, 5)
        topSizer.Add(colorSizer, 0, wx.ALL|wx.EXPAND, 5)

        self.panel.SetSizer(topSizer)
        topSizer.Fit(self)

        self.Layout()


    # ------------ Event handler

    # Event handler on plot canvas
    def onFigureClick(self,event):
        """Event handler for the button click on plot"""
        self.xPress, self.yPress = event.xdata, event.ydata

    def rect_select_callback(self, eclick, erelease):
        """Event handler for rectangle selector on plot"""
        self.xPress, self.yPress = eclick.xdata, eclick.ydata
        self.xRelease, self.yRelease = erelease.xdata, erelease.ydata
        self.xlim = [min(self.xPress,self.xRelease),max(self.xPress,self.xRelease)]
        self.ylim = [ min(self.yPress,self.yRelease),max(self.yPress,self.yRelease)]
        self.drawz(setlim=False)


    # Event handler for animation
    def onAnimationBtn(self,event):
        """Event handler for the button click Animation button"""
        os.system('rm -rf ./Figures/dummy.mp4')
        try:
            os.makedirs('./Figures')
        except:
            pass 
        self.clim = [np.min(self.variable),np.max(self.variable)]
        save_count = self.endTimeIndex - self.startTimeIndex + 1
        self.anim = animation.FuncAnimation(self.figure, self.animate, \
                   frames = range(self.startTimeIndex,self.endTimeIndex+1), repeat=False, \
                   blit = False, save_count=save_count)
        # self.canvas.draw()
        mpl.verbose.set_level("helpful")
        self.anim.save('./Figures/dummy.mp4')

    # Event handler for Save animation
    def onSaveBtn(self,event): 
        """Event handler for the button click Animation button"""
        os.system('rm -rf ./Figures/'+self.variableName+'.mp4')
        try:
            os.makedirs('./Figures')
        except:
            pass 
        time1 = str(self.croco.wrapper._get_date(self.startTimeIndex))
        time2 = str(self.croco.wrapper._get_date(self.endTimeIndex))
        filename = "{:s}_{:s}{:4.1f}_Time{:s}-{:s}.mp4".format(self.variableName,self.slice,self.sliceCoord, \
            time1,time2).replace(" ", "") 
        copyfile('./Figures/dummy.mp4','./Figures/'+filename )

    def animate( self, i):
        """ Function to plot animation in canvas """
        self.timeIndex = i
        self.updateVariableZ(setlim=False)

    def onstartTimeTxt(self,event):
        """Event handler for Enter key in start time text """
        self.startTime = float(self.startTimeTxt.GetValue())
        times = self.croco.wrapper.coords['time'].values
        # find nearest index corresponding to instant time to plot
        self.startTimeIndex = min( range( len(times) ), \
            key=lambda j:abs(self.startTime-times[j]))
        self.startTime = self.croco.wrapper._get_date(self.startTimeIndex)
        self.startTimeTxt.SetValue(str(self.startTime))

    # Event handler for Time dialog
    def onendTimeTxt(self,event):
        """Event handler for Enter key in end time text """
        self.endTime = float(self.endTimeTxt.GetValue())
        times = self.croco.wrapper.coords['time'].values
        # find nearest index corresponding to instant time to plot
        self.endTimeIndex = min( range( len(times) ), \
            key=lambda j:abs(self.endTime-times[j]))
        self.endTime = self.croco.wrapper._get_date(self.endTimeIndex)
        self.endTimeTxt.SetValue(str(self.endTime))

    def onTimeTxt(self,event):
        """Event handler for Enter key in end time text """
        time = float(self.TimeTxt.GetValue())
        times = self.croco.wrapper.coords['time'].values
        # find index corresponding to the nearest instant time to plot
        self.timeIndex = min( range( len(times) ), \
            key=lambda j:abs(time-times[j]))
        self.time = self.croco.wrapper._get_date(self.timeIndex)
        self.TimeTxt.SetValue(str(self.time))
        self.updateVariableZ()

    # Event handler for zoom
    def onZoomInBtn(self,event):    
        """Event handler for the button click Zoom in button"""   
        self.figure.RS.set_active(True)

    def onZoomOutBtn(self,event):
        """Event handler for the button click Zoom out button""" 
        self.xlim = [np.min(self.x),np.max(self.x)]
        self.ylim = [np.min(self.y),np.max(self.y)]
        self.drawz()

    # Event handler for Print
    def onPrintBtn(self,event):
        """Event handler for the button click Print button""" 
        time = str(self.croco.wrapper._get_date(self.timeIndex))
        filename = "{:s}_{:s}{:4.1f}_Time{:s}.png".format(self.variableName,self.slice,self.sliceCoord, \
            time).replace(" ", "")
        # filename = self.variableName + ".png"
        os.system('rm -rf ./Figures/'+filename)
        try:
            os.makedirs('./Figures')
        except:
            pass
        self.figure.savefig('./Figures/'+filename, dpi=self.figure.dpi)

    # Event handler for Color setup
    def onResetColorBtn(self,event):
        """Event handler for the button click Reset Color button""" 
        self.clim = [np.min(self.variable),np.max(self.variable)]
        self.MinColorTxt.SetValue('%.2E' % self.clim[0])
        self.MaxColorTxt.SetValue('%.2E' % self.clim[1])
        self.drawz(setlim=False)

    def onMinColorTxt(self,event):
        """Event handler for Enter key in Min Color text """
        self.clim[0] = float(self.MinColorTxt.GetValue())
        self.drawz(setlim=False)

    def onMaxColorTxt(self,event):
        """Event handler for Enter key in Max Color text """
        self.clim[1] = float(self.MaxColorTxt.GetValue())
        self.drawz(setlim=False)

    #------------- Methods of class

    def updateVariableZ(self,setlim=True):
        """ reload current variable depending on the time and plot it """
        try:
            self.variableZ = self.variable.isel(t=self.timeIndex)
        except:
            return
        self.drawz(setlim=setlim)


    def drawz(self, setlim=True):
        """ plot the current variable in the canvas """
        self.figure.clf()
        self.canvas.mpl_connect('button_press_event', self.onFigureClick)

        if setlim:
            self.mincolor = np.min(self.variableZ.values)
            self.MinColorTxt.SetValue('%.2E' % self.mincolor)
            self.maxcolor = np.max(self.variableZ.values)
            self.MaxColorTxt.SetValue('%.2E' % self.maxcolor)
            self.clim = [self.mincolor,self.maxcolor]
            self.xlim = [np.min(self.x), np.max(self.x)]
            self.ylim = [np.min(self.y), np.max(self.y)]
        time = str(self.croco.wrapper._get_date(self.timeIndex))
        title = "{:s}, {:s}={:4.1f}, Time={:s}".format(self.variableName,self.slice,self.sliceCoord, \
            time)
        mypcolor(self,self.x,self.y,self.variableZ.values,\
                      title=title,\
                      xlabel=self.xlabel,\
                      ylabel='Depth',\
                      xlim=self.xlim,\
                      ylim=self.ylim,\
                      clim=self.clim)

        self.canvas.draw()
        self.canvas.Refresh()
        self.Show()

# end of SectionFrame Class
########################################################################

class ProfileFrame(wx.Frame):
    """ 
    Window class to plot time series or depth profile.
    The window contains a canvas to plot, several buttons (zoom in, zoom out and 
    print ) 

    Attributes:
    croco : croco instance to study
    x : numpy array of x coordinates
    y : numpy array of y coordinates
    variableName : Name of the variable to plot in the canvas
    title : title of the plot
    xlabel : label of x axis
    ylabel : label of y axis
    """

    def __init__(self, croco=None, x=None, y=None, \
        variableName=None, title=None, xlabel=None, ylabel=None):

        # Create the window
        wx.Frame.__init__(self, None, wx.ID_ANY, title='Profile')

        # Now create the Panel to put the other controls on.
        self.panel = wx.Panel(self, wx.ID_ANY)

        # and a few controls
        self.figure = Figure()
        self.canvas = FigureCanvas(self.panel, -1, self.figure)

        self.ZoomInBtn = wx.Button(self.panel, wx.ID_ANY, "Zoom In")
        self.ZoomOutBtn = wx.Button(self.panel, wx.ID_ANY, "Zoom Out")
        self.PrintBtn = wx.Button(self.panel, wx.ID_ANY, "Print")


        # bind the menu event to an event handler
        self.ZoomInBtn.Bind(wx.EVT_BUTTON, self.onZoomInBtn)
        self.ZoomOutBtn.Bind(wx.EVT_BUTTON, self.onZoomOutBtn)
        self.PrintBtn.Bind(wx.EVT_BUTTON, self.onPrintBtn)

        self.__do_layout()

        # Initialize the variables of the class
        self.croco = croco
        self.x = x
        self.y = y
        self.variableName = variableName
        self.title = title
        self.xlabel=xlabel
        self.ylabel=ylabel

    def __do_layout(self):

        """
        Use a sizer to layout the controls, stacked vertically or horizontally
        """
        topSizer        = wx.BoxSizer(wx.VERTICAL)
        canvasSizer     = wx.BoxSizer(wx.VERTICAL)
        buttonsSizer    = wx.BoxSizer(wx.HORIZONTAL)


        canvasSizer.Add(self.canvas, 0, wx.ALL, 5)
        buttonsSizer.Add(self.ZoomInBtn,0, wx.ALL, 5)
        buttonsSizer.Add(self.ZoomOutBtn,0, wx.ALL, 5)
        buttonsSizer.Add(self.PrintBtn,0, wx.ALL, 5)

        topSizer.Add(canvasSizer, 0, wx.CENTER)
        topSizer.Add(buttonsSizer, 0, wx.ALL|wx.EXPAND, 5)

        self.panel.SetSizer(topSizer)
        topSizer.Fit(self)

        self.Layout()

    # ------------ Event handler

    def rect_select_callback(self, eclick, erelease):
        """Event handler for rectangle selector on plot"""
        self.xPress, self.yPress = eclick.xdata, eclick.ydata
        self.xRelease, self.yRelease = erelease.xdata, erelease.ydata
        self.xlim = [min(self.xPress,self.xRelease),max(self.xPress,self.xRelease)]
        self.ylim = [ min(self.yPress,self.yRelease),max(self.yPress,self.yRelease)]
        self.draw(setlim=False)

    def onZoomInBtn(self,event): 
        """Event handler for the button click Zoom in button"""         
        self.figure.RS.set_active(True)

    def onZoomOutBtn(self,event):
        """Event handler for the button click Zoom out button"""   
        self.draw()

    def onPrintBtn(self,event):
        """Event handler for the button click Print button""" 
        filename = self.title.replace(" ", "").replace("=","")+".png"
        os.system('rm -rf ./Figures/'+filename)
        try:
            os.makedirs('./Figures')
        except:
            pass
        self.figure.savefig('./Figures/'+filename, dpi=self.figure.dpi)

    #------------- Methods of class

    def draw(self, setlim=True):
        """ plot the current variable in the canvas """
        if setlim:
            self.xlim = [np.min(self.x), np.max(self.x)]
            self.ylim = [np.min(self.y), np.max(self.y)]
        title=self.title
        plotCurv(self,x=self.x,y=self.y,title=title,xlabel=self.xlabel, \
            ylabel=self.ylabel,xlim=self.xlim, ylim=self.ylim)
        self.canvas.draw()
        self.canvas.Refresh()
        self.Show()

# end of ProfileFrame Class
########################################################################

class CrocoGui(wx.Frame):
    """ 
    Window class to plot the XY sections, manage variables, times, levels and create 
    other windows for vertical sections and profiles

    Attributes:
    title : name of the window
    """

    def __init__(self):

        # Create the window
        wx.Frame.__init__(self, None, wx.ID_ANY, title='Main Window')
        self.Bind(wx.EVT_CLOSE, self.OnClose)

        # Now create the Panel to put the other controls on.
        self.Panel = wx.Panel(self, wx.ID_ANY)

        # and a few controls
        # self.OpenFileBtn = wx.Button(self.Panel, wx.ID_ANY, "Open History File ...")
        # self.OpenFileTxt = wx.StaticText(self.Panel, wx.ID_ANY, " ", style=wx.ALIGN_LEFT)

        self.CrocoVariableChoice = wx.Choice(self.Panel, wx.ID_ANY, choices=["Croco Variables ..."])
        self.CrocoVariableChoice.SetSelection(0)

        self.DerivedVariableChoice = wx.Choice(self.Panel, wx.ID_ANY, choices=["Derived Variables ..."])
        self.DerivedVariableChoice.SetSelection(0)

        self.ResetColorBtn = wx.Button(self.Panel, wx.ID_ANY, "Reset Color")
        self.MinColorTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "Min Color", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.MaxColorTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "Max Color", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)

        self.LabelTime = wx.StaticText(self.Panel,-1,label="Choose Time",style = wx.ALIGN_CENTER)
        self.LabelMinMaxTime = wx.StaticText(self.Panel, wx.ID_ANY, " ", style=wx.ALIGN_LEFT)
        self.TimeMinusBtn = wx.Button(self.Panel, wx.ID_ANY, "<")
        self.TimeTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "Time", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.TimePlusBtn = wx.Button(self.Panel, wx.ID_ANY, ">")

        self.LabelLevel = wx.StaticText(self.Panel,-1,label="Choose level (level>0, depth<0)",style = wx.ALIGN_CENTER)
        self.LabelMinMaxLevel = wx.StaticText(self.Panel, wx.ID_ANY, " ", style=wx.ALIGN_LEFT)
        self.LabelMinMaxDepth = wx.StaticText(self.Panel, wx.ID_ANY, " ", style=wx.ALIGN_LEFT)
        self.LevelMinusBtn = wx.Button(self.Panel, wx.ID_ANY, "<")
        self.LevelTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "Level", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.LevelPlusBtn = wx.Button(self.Panel, wx.ID_ANY, ">")

        self.LonSectionBtn = wx.Button(self.Panel, wx.ID_ANY, "Longitude Section")
        self.LonSectionTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "Longitude", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.LatSectionBtn = wx.Button(self.Panel, wx.ID_ANY, "Latitude Section")
        self.LatSectionTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "Latitude", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.HovmullerBtn = wx.Button(self.Panel, wx.ID_ANY, "Hovmuller")
        self.TimeSeriesBtn = wx.Button(self.Panel, wx.ID_ANY, "Time Series")
        self.VerticalProfileBtn = wx.Button(self.Panel, wx.ID_ANY, "Vertical Profile")

        self.PanelCanvas = wx.Panel(self.Panel, -1)
        self.figure = Figure(figsize=(figsize[0],figsize[1]))
        self.canvas = FigureCanvas(self.PanelCanvas, -1, self.figure)

        self.AnimationBtn = wx.Button(self.Panel, wx.ID_ANY, "Animation")
        self.startTimeTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "1", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.endTimeTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "1", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.ZoomInBtn = wx.Button(self.Panel, wx.ID_ANY, "Zoom In")
        self.ZoomOutBtn = wx.Button(self.Panel, wx.ID_ANY, "Zoom Out")
        self.PrintBtn = wx.Button(self.Panel, wx.ID_ANY, "Print")

        # bind the menu event to an event handler
        # self.OpenFileBtn.Bind(wx.EVT_BUTTON, self.onOpenFile)
        self.CrocoVariableChoice.Bind(wx.EVT_CHOICE, self.onCrocoVariableChoice)
        self.DerivedVariableChoice.Bind(wx.EVT_CHOICE, self.onDerivedVariableChoice)
        self.ResetColorBtn.Bind(wx.EVT_BUTTON, self.onResetColorBtn)
        self.MinColorTxt.Bind(wx.EVT_TEXT_ENTER, self.onMinColorTxt)
        self.MaxColorTxt.Bind(wx.EVT_TEXT_ENTER, self.onMaxColorTxt)
        self.TimeMinusBtn.Bind(wx.EVT_BUTTON, self.onTimeMinusBtn)
        self.TimeTxt.Bind(wx.EVT_TEXT_ENTER, self.onTimeTxt)
        self.TimePlusBtn.Bind(wx.EVT_BUTTON, self.onTimePlusBtn)
        self.LevelMinusBtn.Bind(wx.EVT_BUTTON, self.onLevelMinusBtn)
        self.LevelPlusBtn.Bind(wx.EVT_BUTTON, self.onLevelPlusBtn)
        self.LevelTxt.Bind(wx.EVT_TEXT_ENTER, self.onLevelTxt)
        self.LonSectionBtn.Bind(wx.EVT_BUTTON, self.onLonSectionBtn)
        self.LonSectionTxt.Bind(wx.EVT_TEXT_ENTER, self.onLonSectionTxt)
        self.LatSectionBtn.Bind(wx.EVT_BUTTON, self.onLatSectionBtn)
        self.LatSectionTxt.Bind(wx.EVT_TEXT_ENTER, self.onLatSectionTxt)
        self.HovmullerBtn.Bind(wx.EVT_BUTTON, self.onHovmullerBtn)
        self.TimeSeriesBtn.Bind(wx.EVT_BUTTON, self.onTimeSeriesBtn)
        self.VerticalProfileBtn.Bind(wx.EVT_BUTTON, self.onVerticalProfileBtn)
        self.AnimationBtn.Bind(wx.EVT_BUTTON, self.onAnimationBtn)
        self.startTimeTxt.Bind(wx.EVT_TEXT_ENTER, self.onstartTimeTxt)
        self.endTimeTxt.Bind(wx.EVT_TEXT_ENTER, self.onendTimeTxt)
        self.ZoomInBtn.Bind(wx.EVT_BUTTON, self.onZoomInBtn)
        self.ZoomOutBtn.Bind(wx.EVT_BUTTON, self.onZoomOutBtn)
        self.PrintBtn.Bind(wx.EVT_BUTTON, self.onPrintBtn)

        # self.__set_properties()
        self.__do_layout()

        # ceate a sectionFrame instance to plot XY section
        self.sectionXY = SectionFrame()

        self.currentDirectory = os.getcwd()

        self.openCroco()

    def __do_layout(self):

        """
        Use a sizer to layout the controls, stacked vertically or horizontally
        """

        topSizer        = wx.BoxSizer(wx.HORIZONTAL)
        leftSizer        = wx.BoxSizer(wx.VERTICAL)
        rightSizer        = wx.BoxSizer(wx.VERTICAL)
        # openFileSizer   = wx.BoxSizer(wx.VERTICAL)
        chooseVariablesSizer = wx.BoxSizer(wx.HORIZONTAL)
        colorSizer      = wx.BoxSizer(wx.HORIZONTAL)
        labelTimeSizer  = wx.BoxSizer(wx.HORIZONTAL)
        labelMinMaxTimeSizer  = wx.BoxSizer(wx.HORIZONTAL)
        timeSizer       = wx.BoxSizer(wx.HORIZONTAL)
        labelLevelSizer  = wx.BoxSizer(wx.HORIZONTAL)
        labelMinMaxLevelSizer  = wx.BoxSizer(wx.HORIZONTAL)
        labelMinMaxDepthSizer  = wx.BoxSizer(wx.HORIZONTAL)
        levelSizer       = wx.BoxSizer(wx.HORIZONTAL)
        longitudeSizer  = wx.BoxSizer(wx.HORIZONTAL)
        latitudeSizer   = wx.BoxSizer(wx.HORIZONTAL)
        hovmullerSizer  = wx.BoxSizer(wx.HORIZONTAL)
        timeSeriesSizer = wx.BoxSizer(wx.HORIZONTAL)
        profileSizer   = wx.BoxSizer(wx.HORIZONTAL)
        canvasSizer     = wx.BoxSizer(wx.VERTICAL)
        buttonsSizer    = wx.BoxSizer(wx.HORIZONTAL)

        # openFileSizer.Add(self.OpenFileBtn, 0, wx.ALL, 5)
        # openFileSizer.Add(self.OpenFileTxt, 1, wx.ALL|wx.EXPAND, 5)
        chooseVariablesSizer.Add(self.CrocoVariableChoice, 0, wx.ALL, 5)
        chooseVariablesSizer.Add(self.DerivedVariableChoice, 0, wx.ALL, 5)

        colorSizer.Add(self.ResetColorBtn, 0, wx.ALL, 5)
        colorSizer.Add(self.MinColorTxt, 0, wx.ALL, 5)
        colorSizer.Add(self.MaxColorTxt, 0, wx.ALL, 5)

        labelTimeSizer.Add(self.LabelTime, 0, wx.ALL|wx.EXPAND, 5)
        labelMinMaxTimeSizer.Add(self.LabelMinMaxTime, 0, wx.ALL|wx.EXPAND, 5)
        timeSizer.Add(self.TimeMinusBtn, 0, wx.ALL, 5)
        timeSizer.Add(self.TimeTxt, 0, wx.ALL, 5)
        timeSizer.Add(self.TimePlusBtn, 0, wx.ALL, 5)

        labelLevelSizer.Add(self.LabelLevel, 0, wx.ALL|wx.EXPAND, 5)
        labelMinMaxLevelSizer.Add(self.LabelMinMaxLevel, 0, wx.ALL|wx.EXPAND, 5)
        labelMinMaxDepthSizer.Add(self.LabelMinMaxDepth, 0, wx.ALL|wx.EXPAND, 5)
        levelSizer.Add(self.LevelMinusBtn, 0, wx.ALL, 5)
        levelSizer.Add(self.LevelTxt, 0, wx.ALL, 5)
        levelSizer.Add(self.LevelPlusBtn, 0, wx.ALL, 5)

        longitudeSizer.Add(self.LonSectionBtn, 0, wx.ALL, 5)
        longitudeSizer.Add(self.LonSectionTxt, 0, wx.ALL, 5)

        latitudeSizer.Add(self.LatSectionBtn, 0, wx.ALL, 5)
        latitudeSizer.Add(self.LatSectionTxt, 0, wx.ALL, 5)

        hovmullerSizer.Add(self.HovmullerBtn, 0, wx.ALL, 5)

        timeSeriesSizer.Add(self.TimeSeriesBtn, 0, wx.ALL, 5)

        profileSizer.Add(self.VerticalProfileBtn, 0, wx.ALL, 5)

        canvasSizer.Add(self.PanelCanvas, 1, wx.EXPAND , 5)
        buttonsSizer.Add(self.AnimationBtn,0, wx.ALL, 5)
        buttonsSizer.Add(self.startTimeTxt,1, wx.ALL, 5)
        buttonsSizer.Add(self.endTimeTxt,1, wx.ALL, 5)
        buttonsSizer.Add(self.ZoomInBtn,0, wx.ALL, 5)
        buttonsSizer.Add(self.ZoomOutBtn,0, wx.ALL, 5)
        buttonsSizer.Add(self.PrintBtn,0, wx.ALL, 5)

        # leftSizer.Add(openFileSizer, 0,wx.ALL|wx.EXPAND, 5 )
        leftSizer.Add(chooseVariablesSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(labelTimeSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(labelMinMaxTimeSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(timeSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(labelLevelSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(labelMinMaxLevelSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(labelMinMaxDepthSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(levelSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(longitudeSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(latitudeSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(hovmullerSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(timeSeriesSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(profileSizer, 0, wx.ALL|wx.EXPAND, 5)
        rightSizer.Add(canvasSizer, 0, wx.EXPAND)
        rightSizer.Add(buttonsSizer, 0, wx.ALL|wx.EXPAND, 5)
        rightSizer.Add(colorSizer, 0, wx.ALL|wx.EXPAND, 5)

        topSizer.Add(leftSizer, 0,wx.ALL|wx.EXPAND, 5 )
        topSizer.Add(rightSizer, 0,wx.EXPAND, 5 )

        self.Panel.SetSizer(topSizer)
        self.Panel.SetAutoLayout(True)
        topSizer.Fit(self)


        self.Layout()

    # ------------ Event handler
    def OnClose(self,event):
        self.Destroy()
        sys.exit()


    def onFigureClick(self,event):
        self.lon, self.lat = event.xdata, event.ydata
        self.latIndex,self.lonIndex = self.findLatLonIndex(self.lon, self.lat)
        self.LonSectionTxt.SetValue('%.2F' % self.lon)
        self.LatSectionTxt.SetValue('%.2F' % self.lat)

    def rect_select_callback(self, eclick, erelease):
        self.xPress, self.yPress = eclick.xdata, eclick.ydata
        self.xRelease, self.yRelease = erelease.xdata, erelease.ydata
        self.xlim = [min(self.xPress,self.xRelease),max(self.xPress,self.xRelease)]
        self.ylim = [ min(self.yPress,self.yRelease),max(self.yPress,self.yRelease)]
        self.drawxy(setlim=False)

    # def onOpenFile(self, event):
    def openCroco(self):
        """
        Create and show the Open FileDialog to select file name
        Initialize few outputs
        """
        # dlg = wx.FileDialog(
        #     self, message="Choose a file",
        #     defaultDir=self.currentDirectory, 
        #     defaultFile="",
        #     wildcard=wildcard,
        #     style=wx.FD_OPEN | wx.FD_MULTIPLE | wx.FD_CHANGE_DIR
        #     )
        # if dlg.ShowModal() == wx.ID_OK:
        #     paths = dlg.GetPaths()
        # dlg.Destroy()
        self.croco = Croco() 
        timeMin = self.croco.wrapper._get_date(0)
        timeMax = self.croco.wrapper._get_date(self.croco.wrapper.ntimes-1)
        self.LabelMinMaxTime.SetLabel("Min/Max Time = "+str(timeMin)+" ... "+str(timeMax)+ "days") 
        self.TimeTxt.SetValue(str(timeMin))
        self.timeIndex = 0
        self.time = timeMin
        minLevel = 1
        maxLevel = int(self.croco.wrapper.N)
        minDepth = - int(self.croco.wrapper.metrics['h'].max())
        maxDepth = 0
        self.LabelMinMaxLevel.SetLabel("Min/Max Level = 1 ... "+ str(maxLevel))
        self.LabelMinMaxDepth.SetLabel("Min/Max Depth = "+ str(minDepth)+" ... "+str(maxDepth))
        self.levelIndex=self.croco.wrapper.N - 1
        self.LevelTxt.SetValue(str(self.levelIndex+1))
        self.depth = self.levelIndex + 1
        self.startTimeTxt.SetValue(str(timeMin))
        self.startTime = timeMin
        self.startTimeIndex = 0
        self.endTimeTxt.SetValue(str(timeMax))
        self.endTime = timeMax
        self.endTimeIndex = self.croco.wrapper.ntimes -1
        self.CrocoVariableChoice.AppendItems(self.croco.ListOfVariables)


    def onCrocoVariableChoice(self, event):
        '''
        Choose variable to plot, update text zone for color, launch plot
        '''
        self.variableName = self.CrocoVariableChoice.GetString(self.CrocoVariableChoice.GetSelection())
        time = str(self.timeIndex)
        level = str(self.levelIndex)
        try:
            self.variableXY = self.croco.variables[self.variableName].isel(t=self.timeIndex,z_r=self.levelIndex)
        except:
            self.variableXY = self.croco.variables[self.variableName].isel(t=self.timeIndex)

        self.mincolor = np.min(self.variableXY.values)
        self.MinColorTxt.SetValue('%.2E' % self.mincolor)
        self.maxcolor = np.max(self.variableXY.values)
        self.MaxColorTxt.SetValue('%.2E' % self.maxcolor)
        self.clim = [self.mincolor,self.maxcolor]
        self.xlim = [np.min(self.croco.wrapper.coords['lon_r'].values), \
                     np.max(self.croco.wrapper.coords['lon_r'].values)]
        self.ylim = [np.min(self.croco.wrapper.coords['lat_r'].values), \
                     np.max(self.croco.wrapper.coords['lat_r'].values)]
        self.drawxy()

    def onDerivedVariableChoice(self, event):
        self.variableName = self.DerivedVariableChoice.GetString(self.DerivedVariableChoice.GetSelection())
        # print("Not implemented yet")
        print "Not implemented yet"

    def onResetColorBtn(self,event):
        self.clim = [np.min(self.variableXY.values),np.max(self.variableXY.values)]
        self.MinColorTxt.SetValue('%.2E' % self.clim[0])
        self.MaxColorTxt.SetValue('%.2E' % self.clim[1])
        self.drawxy()

    def onMinColorTxt(self,event):
        self.clim[0] = float(self.MinColorTxt.GetValue())
        self.drawxy(setlim=False)

    def onMaxColorTxt(self,event):
        self.clim[1] = float(self.MaxColorTxt.GetValue())
        self.drawxy(setlim=False)


    def onTimeMinusBtn(self,event):
        self.timeIndex = max(self.timeIndex - 1,0)
        self.time = self.croco.wrapper._get_date(self.timeIndex)
        self.TimeTxt.SetValue(str(self.time))
        self.updateVariableXY()
        self.drawxy()

    def onTimePlusBtn(self,event):
        self.timeIndex = min(self.timeIndex + 1,self.croco.wrapper.ntimes - 1)
        self.time = self.croco.wrapper._get_date(self.timeIndex)
        self.TimeTxt.SetValue(str(self.time))
        self.updateVariableXY()
        self.drawxy()

    def onTimeTxt(self,event):
        time = float(self.TimeTxt.GetValue())
        times = self.croco.wrapper.coords['time'].values
        # find index corresponding to the nearest instant time to plot
        self.timeIndex = min( range( len(times) ), \
            key=lambda j:abs(time-times[j]))
        self.time = self.croco.wrapper._get_date(self.timeIndex)
        self.TimeTxt.SetValue(str(self.time))
        self.updateVariableXY()
        self.drawxy()

    def onLevelMinusBtn(self,event):
        self.levelIndex = max(self.levelIndex - 1,0)
        self.depth = self.levelIndex + 1
        self.LevelTxt.SetValue(str(self.levelIndex + 1))
        self.updateVariableXY()
        self.drawxy()

    def onLevelPlusBtn(self,event):
        self.levelIndex = min(self.levelIndex + 1,self.croco.wrapper.N - 1)
        self.depth = self.levelIndex + 1
        self.LevelTxt.SetValue(str(self.levelIndex + 1))
        self.updateVariableXY()
        self.drawxy()

    def onLevelTxt(self,event):
        time = str(self.timeIndex)
        depth = float(self.LevelTxt.GetValue())
        if depth > 0:
            self.levelIndex = int(self.LevelTxt.GetValue()) - 1
            self.depth = self.levelIndex + 1
            self.updateVariableXY()
        elif depth < 0:
            self.depth = depth
            # Calculate depths 
            ssh = self.croco.variables['ssh'].isel(t=self.timeIndex).values
            if self.variableName=="u":
                z = self.croco.wrapper.scoord2z_u(ssh, alpha=0., beta=0)
            elif self.variableName=="v":
                z = self.croco.wrapper.scoord2z_v(ssh, alpha=0., beta=0)
            else :
                z = self.croco.wrapper.scoord2z_r(ssh, alpha=0., beta=0)
            minlev,maxlev = self.croco.zslice(None,self.croco.wrapper.masks['mask_r'],z,depth,findlev=True)
            var = self.croco.variables[self.variableName].isel(t=self.timeIndex, z_r=slice(minlev,maxlev+1))
            dims = self.croco.variables[self.variableName].dims
            mask = self.croco.wrapper.masks['mask_r']
            if "x_u" in dims:
                mask = self.croco.rho2u_2d(mask)
            elif "y_v" in dims:
                mask = self.croco.rho2v_2d(mask)
            zslice = self.croco.zslice(var.values,mask,z[minlev:maxlev+1,:,:],depth)[0]
            self.variableXY = xr.DataArray(data=zslice)
        else:
            # print("baraotrope")
            print "baraotrope"
        self.drawxy()

    def onLonSectionBtn(self,event):
        # if variable without z dimension
        if len(self.croco.variables[self.variableName].dims) < 4 :
            return
        # Get longitude section of current variable
        variable = self.croco.get_variable(self.variableName, \
            xindex=self.lonIndex)
        # Get Latitude coordinates
        x = self.croco.get_coord(self.variableName, direction='y')
        x = repmat(x[:,self.lonIndex].squeeze(),self.croco.wrapper.N,1)
        # Calculate depths of the slice
        ssh = self.croco.variables['ssh'].isel(t=self.timeIndex).values
        if self.variableName=="u":
            y = self.croco.wrapper.scoord2z_u(ssh, alpha=0., beta=0)[:,:,self.lonIndex]
        elif self.variableName=="v":
            y = self.croco.wrapper.scoord2z_v(ssh, alpha=0., beta=0)[:,:,self.lonIndex]
        else :
            y = self.croco.wrapper.scoord2z_r(ssh, alpha=0., beta=0)[:,:,self.lonIndex]
        self.sectionYZ = SectionFrame(\
            croco=self.croco, \
            variableName = self.variableName, \
            variable=variable, 
            x=x, y=y, \
            typSection="YZ" , \
            sliceCoord = self.lon, \
            timeIndex=self.timeIndex)
        # Draw the plot
        self.sectionYZ.updateVariableZ()

    def onLonSectionTxt(self,event):
        # if variable without z dimension
        if len(self.croco.variables[self.variableName].dims) < 4 :
            return
        self.lon = float(self.LonSectionTxt.GetValue())
        self.latIndex,self.lonIndex = self.findLatLonIndex(self.lon, self.lat) 

        # Get longitude section of current variable
        variable = self.croco.get_variable(self.variableName, \
            xindex=self.lonIndex)
        # Get Latitude coordinates
        x = self.croco.get_coord(self.variableName, direction='y')
        x = repmat(x[:,self.lonIndex].squeeze(),self.croco.wrapper.N,1)
        # Calculate depths of the slice
        ssh = self.croco.variables['ssh'].isel(t=self.timeIndex).values
        if self.variableName=="u":
            y = self.croco.wrapper.scoord2z_u(ssh, alpha=0., beta=0)[:,:,self.lonIndex]
        elif self.variableName=="v":
            y = self.croco.wrapper.scoord2z_v(ssh, alpha=0., beta=0)[:,:,self.lonIndex]
        else :
            y = self.croco.wrapper.scoord2z_r(ssh, alpha=0., beta=0)[:,:,self.lonIndex]
        self.sectionYZ = SectionFrame(\
            croco=self.croco, \
            variableName = self.variableName, \
            variable=variable, 
            x=x, y=y, \
            typSection="YZ" , \
            sliceCoord = self.lon, \
            timeIndex=self.timeIndex)
        # Draw the plot
        self.sectionYZ.updateVariableZ()

    def onLatSectionBtn(self,event):
        # if variable without z dimension
        if len(self.croco.variables[self.variableName].dims) < 4 :
            return
        # Get latitude section of current variable
        variable = self.croco.get_variable(self.variableName, \
            yindex=self.latIndex)
        # Get Latitude coordinates
        x = self.croco.get_coord(self.variableName, direction='x')
        x = repmat(x[self.latIndex,:].squeeze(),self.croco.wrapper.N,1)
        # Calculate depths of the slice
        ssh = self.croco.variables['ssh'].isel(t=self.timeIndex).values
        if self.variableName=="u":
            y = self.croco.wrapper.scoord2z_u(ssh, alpha=0., beta=0)[:,self.latIndex,:]
        elif self.variableName=="v":
            y = self.croco.wrapper.scoord2z_v(ssh, alpha=0., beta=0)[:,self.latIndex,:]
        else :
            y = self.croco.wrapper.scoord2z_r(ssh, alpha=0., beta=0)[:,self.latIndex,:]
        self.sectionXZ = SectionFrame(\
            croco=self.croco, \
            variableName = self.variableName, \
            variable=variable, 
            x=x, y=y, \
            typSection="XZ" , \
            sliceCoord = self.lat, \
            timeIndex=self.timeIndex)
        # Draw the plot
        self.sectionXZ.updateVariableZ()


    def onLatSectionTxt(self,event):
        # if variable without z dimension
        if len(self.croco.variables[self.variableName].dims) < 4 :
            return
        self.lat = float(self.LatSectionTxt.GetValue())
        self.latIndex,self.lonIndex = self.findLatLonIndex(self.lon, self.lat) 
        # Get latitude section of current variable
        variable = self.croco.get_variable(self.variableName, \
            yindex=self.latIndex)
        # Get Latitude coordinates
        x = self.croco.get_coord(self.variableName, direction='x')
        x = repmat(x[self.latIndex,:].squeeze(),self.croco.wrapper.N,1)
        # Calculate depths of the slice
        ssh = self.croco.variables['ssh'].isel(t=self.timeIndex).values
        if self.variableName=="u":
            y = self.croco.wrapper.scoord2z_u(ssh, alpha=0., beta=0)[:,self.latIndex,:]
        elif self.variableName=="v":
            y = self.croco.wrapper.scoord2z_v(ssh, alpha=0., beta=0)[:,self.latIndex,:]
        else :
            y = self.croco.wrapper.scoord2z_r(ssh, alpha=0., beta=0)[:,self.latIndex,:]
        self.sectionXZ = SectionFrame(\
            croco=self.croco, \
            variableName = self.variableName, \
            variable=variable, 
            x=x, y=y, \
            typSection="XZ" , \
            sliceCoord = self.lat, \
            timeIndex=self.timeIndex)
        # Draw the plot
        self.sectionXZ.updateVariableZ()


    def onHovmullerBtn(self,event):
        # print("Hovmuller not implemented yet!!!")
        print "Hovmuller not implemented yet!!!"

    def onTimeSeriesBtn(self,event):
        x = self.croco.wrapper.coords['time'].values.astype('timedelta64[D]').astype('float')
        y = self.croco.get_variable(self.variableName, \
            xindex=self.lonIndex, yindex=self.latIndex, zindex=self.levelIndex).values
        title="{:s}, Lon={:4.1f}, Lat={:4.1f}, Depth={:4.0f}".\
            format(self.variableName,self.lon,self.lat, self.depth)    
        self.timeFrame = ProfileFrame(croco=self.croco, \
            x=x, y=y, \
            variableName=self.variableName, \
            title=title, \
            xlabel="Time (days)")
        self.timeFrame.draw()

    def onVerticalProfileBtn(self,event):
        if len(self.croco.variables[self.variableName].dims) < 4 :
            return
        time = str(self.croco.wrapper._get_date(self.timeIndex))
        title="{:s}, Lon={:4.1f}, Lat={:4.1f}, Time={:s}".\
            format(self.variableName,self.lon,self.lat,time)
        # Calculate depths of the slice
        ssh = self.croco.variables['ssh'].isel(t=self.timeIndex).values
        if self.variableName=="u":
            z = self.croco.wrapper.scoord2z_u(ssh, alpha=0., beta=0)[:,self.latIndex,self.lonIndex]
        elif self.variableName=="v":
            z = self.croco.wrapper.scoord2z_v(ssh, alpha=0., beta=0)[:,self.latIndex,self.lonIndex]
        else :
            z = self.croco.wrapper.scoord2z_r(ssh, alpha=0., beta=0)[:,self.latIndex,self.lonIndex]

        x = self.croco.get_variable(self.variableName, \
            xindex=self.lonIndex, yindex=self.latIndex, tindex=self.timeIndex).values
        self.profileFrame = ProfileFrame(croco=self.croco, \
            x=x, y=z, \
            variableName=self.variableName, \
            title=title,
            ylabel="Depth (m)")
        self.profileFrame.draw()

    def onAnimationBtn(self,event):
        os.system('rm -rf ./Figures/'+self.variableName+'.mp4')
        try:
            os.makedirs('./Figures')
        except:
            pass
        self.clim = [np.min(self.variableXY),np.max(self.variableXY)]
        save_count = self.endTimeIndex - self.startTimeIndex + 1
        anim = animation.FuncAnimation(self.figure, self.animate, \
                   frames = range(self.startTimeIndex,self.endTimeIndex+1), repeat=False, \
                   blit = False, save_count=save_count)
        self.canvas.draw()
        time1 = str(self.croco.wrapper._get_date(self.startTimeIndex))
        time2 = str(self.croco.wrapper._get_date(self.endTimeIndex))
        filename = "{:s}_Depth={:4.0f}_{:s}-{:s}.mp4".format(self.variableName,self.depth,time1,time2)
        filename=filename.replace(" ","")
        anim.save('./Figures/'+filename)

    def animate( self, i):
        self.timeIndex = i
        self.updateVariableXY(setlim=False)

    def onstartTimeTxt(self,event):
        self.startTime = float(self.startTimeTxt.GetValue())
        times = self.croco.wrapper.coords['time'].values
        # find index corresponding to instant time to plot
        self.startTimeIndex = min( range( len(times) ), \
            key=lambda j:abs(self.startTime-times[j]))
        self.startTime = self.croco.wrapper._get_date(self.startTimeIndex)
        self.startTimeTxt.SetValue(str(self.startTime))

    def onendTimeTxt(self,event):
        self.endTime = float(self.endTimeTxt.GetValue())
        times = self.croco.wrapper.coords['time'].values
        # find index corresponding to instant time to plot
        self.endTimeIndex = min( range( len(times) ), \
            key=lambda j:abs(self.endTime-times[j]))
        self.endTime = self.croco.wrapper._get_date(self.endTimeIndex)
        self.endTimeTxt.SetValue(str(self.endTime))

    def onZoomInBtn(self,event):
        self.figure.RS.set_active(True)

    def onZoomOutBtn(self,event):
        self.xlim = [np.min(self.croco.wrapper.coords['lon_r'].values), \
                     np.max(self.croco.wrapper.coords['lon_r'].values)]
        self.ylim = [np.min(self.croco.wrapper.coords['lat_r'].values), \
                     np.max(self.croco.wrapper.coords['lat_r'].values)]
        self.drawxy()

    def onPrintBtn(self,event):
        time = str(self.croco.wrapper._get_date(self.timeIndex))
        filename = "{:s}_Depth={:4.0f}_Time{:s}".format(self.variableName,self.depth,time)
        filename=filename.replace(" ","")+".png"
        os.system('rm -rf ./Figures/'+filename)
        try:
            os.makedirs('./Figures')
        except:
            pass
        self.figure.savefig('./Figures/'+filename, dpi=self.figure.dpi)


    #------------- Methods of class


    def findLatLonIndex(self, lonValue, latValue):
        ''' Find nearest  grid point of  click value '''
        a = abs(self.croco.wrapper.coords['lon_r'].values - lonValue) + \
            abs(self.croco.wrapper.coords['lat_r'].values - latValue)
        return np.unravel_index(a.argmin(),a.shape)


    def updateVariableXY(self,setlim=True):
        try:
            self.variableXY = self.croco.variables[self.variableName].isel(t=self.timeIndex,z_r=self.levelIndex)
        except:
            self.variableXY = self.croco.variables[self.variableName].isel(t=self.timeIndex)
        self.drawxy(setlim=setlim)


    def drawxy(self,setlim=True):
        self.figure.clf()
        self.canvas.mpl_connect('button_press_event', self.onFigureClick)

        if setlim:
            self.mincolor = np.min(self.variableXY.values)
            self.MinColorTxt.SetValue('%.2E' % self.mincolor)
            self.maxcolor = np.max(self.variableXY.values)
            self.MaxColorTxt.SetValue('%.2E' % self.maxcolor)
            self.clim = [self.mincolor,self.maxcolor]
            self.xlim = [np.min(self.croco.wrapper.coords['lon_r'].values), \
                         np.max(self.croco.wrapper.coords['lon_r'].values)]
            self.ylim = [np.min(self.croco.wrapper.coords['lat_r'].values), \
                         np.max(self.croco.wrapper.coords['lat_r'].values)]


        time = str(self.croco.wrapper._get_date(self.timeIndex))
        depth = float(self.LevelTxt.GetValue())
        lon = self.croco.wrapper.coords['lon_r'].values
        lat = self.croco.wrapper.coords['lat_r'].values

        if depth > 0:
            title = "{:s}, Level={:4d}, Time={:s}".format(self.variableName,self.levelIndex+1,time)
        else:
            # title = "{:s}, Depth={:4.1f}, Time={:4.1f}".format(self.variableName,depth,time)
            title = "{:s}, Depth={:4.1f}, Time={:s}".format(self.variableName,depth,time)
        mypcolor(self,lon,lat,self.variableXY.values,\
                      title=title,\
                      xlabel='Longitude',\
                      ylabel='Latitude',\
                      xlim=self.xlim,\
                      ylim=self.ylim,\
                      clim=self.clim)
        
        self.canvas.draw()
        self.canvas.Refresh()
        self.Refresh()


# end of class CrocoGui


# Run the program
if __name__ == "__main__":
    app = wx.App(False)
    frame = CrocoGui()
    frame.Show()
    app.MainLoop()
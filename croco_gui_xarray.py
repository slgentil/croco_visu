# -*- coding: UTF-8 -*-
#
# generated by wxGlade 0.8.0b3 on Tue Jan 30 13:49:27 2018
#

import sys
import os
import wx
import time
from datetime import datetime
import xarray as xr
import numpy as np
from numpy.matlib import repmat
import numpy.ma as ma
import scipy.io
import netCDF4 as netcdf
import matplotlib.pyplot as plt
# import matplotlib
# matplotlib.use('WXAgg')
from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas
from matplotlib.figure import Figure
from matplotlib import colors
from matplotlib import animation
from matplotlib.widgets  import RectangleSelector
from CrocoXarray import Croco
from myplot import plotCurv, mypcolor

wildcard = "Netcdf Files (*.nc)|*.nc"
# figsize = [10,9]
figsize = [6,5]

# begin wxGlade: dependencies
# end wxGlade

# begin wxGlade: extracode
# end wxGlade

########################################################################

class SectionFrame(wx.Frame):

    def __init__(self, croco=None, variableName = None, variable=None, x=None, y=None, \
        typSection=None , sliceCoord = None, timeIndex=None):

        """Constructor"""

        wx.Frame.__init__(self, None, wx.ID_ANY, title='Section')

        self.panel = wx.Panel(self, wx.ID_ANY)

        self.figure = Figure()
        self.axes = self.figure.add_axes([0,0,1,1])
        self.canvas = FigureCanvas(self.panel, -1, self.figure)
        self.canvas.mpl_connect('button_press_event', self.onFigureClick)
        self.canvas.mpl_connect('button_release_event', self.onFigureRelease)
        # self.canvas.mpl_connect('motion_notify_event', self.onFigureMotion)

        self.AnimationBtn = wx.Button(self.panel, wx.ID_ANY, "Animation")
        self.AnimationBtn.Bind(wx.EVT_BUTTON, self.onAnimationBtn)
        self.startTimeTxt = wx.TextCtrl(self.panel, wx.ID_ANY, "1", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.startTimeTxt.Bind(wx.EVT_TEXT_ENTER, self.onstartTimeTxt)
        self.endTimeTxt = wx.TextCtrl(self.panel, wx.ID_ANY, "1", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.endTimeTxt.Bind(wx.EVT_TEXT_ENTER, self.onendTimeTxt)
        self.ZoomInBtn = wx.Button(self.panel, wx.ID_ANY, "Zoom In")
        self.ZoomInBtn.Bind(wx.EVT_BUTTON, self.onZoomInBtn)
        self.ZoomOutBtn = wx.Button(self.panel, wx.ID_ANY, "Zoom Out")
        self.ZoomOutBtn.Bind(wx.EVT_BUTTON, self.onZoomOutBtn)
        self.PrintBtn = wx.Button(self.panel, wx.ID_ANY, "Print")
        self.PrintBtn.Bind(wx.EVT_BUTTON, self.onPrintBtn)
        
        self.ResetColorBtn = wx.Button(self.panel, wx.ID_ANY, "Reset Color")
        self.ResetColorBtn.Bind(wx.EVT_BUTTON, self.onResetColorBtn)
        self.MinColorTxt = wx.TextCtrl(self.panel, wx.ID_ANY, "Min Color", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.MinColorTxt.Bind(wx.EVT_TEXT_ENTER, self.onMinColorTxt)
        self.MaxColorTxt = wx.TextCtrl(self.panel, wx.ID_ANY, "Max Color", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.MaxColorTxt.Bind(wx.EVT_TEXT_ENTER, self.onMaxColorTxt)

        self.__do_layout()

        self.croco = croco
        self.variable = variable
        self.x = x
        self.y = y
        self.variableName = variableName
        self.typSection = typSection
        self.sliceCoord = sliceCoord
        self.timeIndex = timeIndex
        if croco is not None:
            self.time = self.croco.wrapper.coords['time']
        if typSection == "XZ":
            self.xlabel = "Longitude"
            self.ylabel = "Depth"
            self.slice = "Latitude"
        elif typSection == "YZ":
            self.xlabel = "Latitude"
            self.ylabel = "Depth"
            self.slice = "Longitude"
        # self.sectionYZ.latlon = self.lon
        # self.sectionYZ.latlonIndex = self.lonIndex
        if croco is not None:
            timeMin = self.croco.wrapper._get_date(0)
            timeMax = self.croco.wrapper._get_date(self.croco.wrapper.ntimes-1)
            self.startTimeTxt.SetValue(str(timeMin))
            self.startTime = timeMin
            self.startTimeIndex = 0
            self.endTimeTxt.SetValue(str(timeMax))
            self.endTime = timeMax
            self.endTimeIndex = self.croco.wrapper.ntimes -1

    def __do_layout(self):

        topSizer        = wx.BoxSizer(wx.VERTICAL)
        canvasSizer     = wx.BoxSizer(wx.VERTICAL)
        buttonsSizer    = wx.BoxSizer(wx.HORIZONTAL)
        colorSizer      = wx.BoxSizer(wx.HORIZONTAL)


        canvasSizer.Add(self.canvas, 0, wx.ALL, 5)
        buttonsSizer.Add(self.AnimationBtn,0, wx.ALL, 5)
        buttonsSizer.Add(self.startTimeTxt,1, wx.ALL, 5)
        buttonsSizer.Add(self.endTimeTxt,1, wx.ALL, 5)
        buttonsSizer.Add(self.ZoomInBtn,0, wx.ALL, 5)
        buttonsSizer.Add(self.ZoomOutBtn,0, wx.ALL, 5)
        buttonsSizer.Add(self.PrintBtn,0, wx.ALL, 5)
        colorSizer.Add(self.ResetColorBtn, 0, wx.ALL, 5)
        colorSizer.Add(self.MinColorTxt, 0, wx.ALL, 5)
        colorSizer.Add(self.MaxColorTxt, 0, wx.ALL, 5)

        topSizer.Add(canvasSizer, 0, wx.CENTER)
        topSizer.Add(buttonsSizer, 0, wx.ALL|wx.EXPAND, 5)
        topSizer.Add(colorSizer, 0, wx.ALL|wx.EXPAND, 5)

        self.panel.SetSizer(topSizer)
        topSizer.Fit(self)

        self.Layout()

    def onFigureClick(self,event):
        self.xPress, self.yPress = event.xdata, event.ydata

    def onFigureRelease(self,event):
        self.xRelease, self.yRelease = event.xdata, event.ydata

    def rect_select_callback(self, eclick, erelease):
        self.xPress, self.yPress = eclick.xdata, eclick.ydata
        self.xRelease, self.yRelease = erelease.xdata, erelease.ydata
        self.xlim = [min(self.xPress,self.xRelease),max(self.xPress,self.xRelease)]
        self.ylim = [ min(self.yPress,self.yRelease),max(self.yPress,self.yRelease)]
        self.drawz(setlim=False)
    #     print(" The button you used were: %s %s" % (eclick.button, erelease.button))






    def onAnimationBtn(self,event):
        os.system('rm -rf ./Figures/'+self.variableName+'.mp4')
        try:
            os.makedirs('./Figures')
        except:
            pass
        self.clim = [np.min(self.variable),np.max(self.variable)]
        save_count = self.endTimeIndex - self.startTimeIndex + 1
        anim = animation.FuncAnimation(self.figure, self.animate, \
                   frames = range(self.startTimeIndex,self.endTimeIndex+1), repeat=False, \
                   blit = False, save_count=save_count)
        self.canvas.draw()
        time1 = str(self.croco.wrapper._get_date(self.startTimeIndex))
        time2 = str(self.croco.wrapper._get_date(self.endTimeIndex))
        filename = "{:s}_{:s}{:4.1f}_{:s}-{:s}.mp4".format(self.variableName,self.slice,self.sliceCoord, \
            time1,time2).replace(" ", "")
        anim.save('./Figures/'+filename)

    def animate( self, i):
        self.timeIndex = i
        self.updateVariableZ(setlim=False)

    def onstartTimeTxt(self,event):
        self.startTime = float(self.startTimeTxt.GetValue())
        times = self.croco.wrapper.coords['time'].values
        # find nearest index corresponding to instant time to plot
        self.startTimeIndex = min( range( len(times) ), \
            key=lambda j:abs(self.startTime-times[j]))
        self.startTime = self.croco.wrapper._get_date(self.startTimeIndex)
        self.startTimeTxt.SetValue(str(self.startTime))

    def onendTimeTxt(self,event):
        self.endTime = float(self.endTimeTxt.GetValue())
        times = self.croco.wrapper.coords['time'].values
        # find index corresponding to the nearest instant time to plot
        self.endTimeIndex = min( range( len(times) ), \
            key=lambda j:abs(self.endTime-times[j]))
        self.endTime = self.croco.wrapper._get_date(self.endTimeIndex)
        self.endTimeTxt.SetValue(str(self.endTime))



    def onZoomInBtn(self,event):       
        self.figure.RS.set_active(True)

    def onZoomOutBtn(self,event):
        self.xlim = [np.min(self.x),np.max(self.x)]
        self.ylim = [np.min(self.y),np.max(self.y)]
        self.drawz()

    def onPrintBtn(self,event):
        time = str(self.croco.wrapper._get_date(self.timeIndex))
        filename = "{:s}_{:s}{:4.1f}_Time{:s}.png".format(self.variableName,self.slice,self.sliceCoord, \
            time).replace(" ", "")
        # filename = self.variableName + ".png"
        os.system('rm -rf ./Figures/'+filename)
        try:
            os.makedirs('./Figures')
        except:
            pass
        self.figure.savefig('./Figures/'+filename, dpi=self.figure.dpi)

    def onResetColorBtn(self,event):
        self.clim = [np.min(self.variable),np.max(self.variable)]
        self.MinColorTxt.SetValue('%.2E' % self.clim[0])
        self.MaxColorTxt.SetValue('%.2E' % self.clim[1])
        self.drawz(setlim=False)

    def onMinColorTxt(self,event):
        self.clim[0] = float(self.MinColorTxt.GetValue())
        self.drawz(setlim=False)

    def onMaxColorTxt(self,event):
        self.clim[1] = float(self.MaxColorTxt.GetValue())
        self.drawz(setlim=False)

    def updateVariableZ(self,setlim=True):
        try:
            self.variableZ = self.variable.isel(t=self.timeIndex)
        except:
            return
        self.drawz(setlim=setlim)


    def drawz(self, setlim=True):
        self.figure.clf()
        # self.canvas.Destroy()
        # self.figure = Figure(figsize=(figsize[0],figsize[1]))
        # self.canvas = FigureCanvas(self.panel, -1, self.figure)
        self.canvas.mpl_connect('button_press_event', self.onFigureClick)
        self.canvas.mpl_connect('button_release_event', self.onFigureRelease)

        if setlim:
            self.mincolor = np.min(self.variableZ.values)
            self.MinColorTxt.SetValue('%.2E' % self.mincolor)
            self.maxcolor = np.max(self.variableZ.values)
            self.MaxColorTxt.SetValue('%.2E' % self.maxcolor)
            self.clim = [self.mincolor,self.maxcolor]
            self.xlim = [np.min(self.x), np.max(self.x)]
            self.ylim = [np.min(self.y), np.max(self.y)]
        time = str(self.croco.wrapper._get_date(self.timeIndex))
        title = "{:s}, {:s}={:4.1f}, Time={:s}".format(self.variableName,self.slice,self.sliceCoord, \
            time)
        mypcolor(self,self.x,self.y,self.variableZ.values,\
                      title=title,\
                      xlabel=self.xlabel,\
                      ylabel='Depth',\
                      xlim=self.xlim,\
                      ylim=self.ylim,\
                      clim=self.clim)

        self.canvas.draw()
        self.canvas.Refresh()
        self.Show()


########################################################################

class ProfileFrame(wx.Frame):

    def __init__(self, croco=None, profile=None, x=None, y=None, \
        variableName=None, title=None, xlabel=None, ylabel=None):

        """Constructor"""

        wx.Frame.__init__(self, None, wx.ID_ANY, title='Profile')

        self.panel = wx.Panel(self, wx.ID_ANY)

        self.figure = Figure()
        # self.axes = self.figure.add_axes([0.1,0.1,0.9,0.9])
        self.canvas = FigureCanvas(self.panel, -1, self.figure)

        self.ZoomInBtn = wx.Button(self.panel, wx.ID_ANY, "Zoom In")
        self.ZoomInBtn.Bind(wx.EVT_BUTTON, self.onZoomInBtn)
        self.ZoomOutBtn = wx.Button(self.panel, wx.ID_ANY, "Zoom Out")
        self.ZoomOutBtn.Bind(wx.EVT_BUTTON, self.onZoomOutBtn)
        self.PrintBtn = wx.Button(self.panel, wx.ID_ANY, "Print")
        self.PrintBtn.Bind(wx.EVT_BUTTON, self.onPrintBtn)


        self.__do_layout()
        self.croco = croco
        self.x = x
        self.y = y
        self.variableName = variableName
        self.title = title
        self.xlabel=xlabel
        self.ylabel=ylabel

    def __do_layout(self):

        topSizer        = wx.BoxSizer(wx.VERTICAL)
        canvasSizer     = wx.BoxSizer(wx.VERTICAL)
        buttonsSizer    = wx.BoxSizer(wx.HORIZONTAL)


        canvasSizer.Add(self.canvas, 0, wx.ALL, 5)
        buttonsSizer.Add(self.ZoomInBtn,0, wx.ALL, 5)
        buttonsSizer.Add(self.ZoomOutBtn,0, wx.ALL, 5)
        buttonsSizer.Add(self.PrintBtn,0, wx.ALL, 5)

        topSizer.Add(canvasSizer, 0, wx.CENTER)
        topSizer.Add(buttonsSizer, 0, wx.ALL|wx.EXPAND, 5)

        self.panel.SetSizer(topSizer)
        topSizer.Fit(self)

        # self.Layout()


    def rect_select_callback(self, eclick, erelease):
        self.xPress, self.yPress = eclick.xdata, eclick.ydata
        self.xRelease, self.yRelease = erelease.xdata, erelease.ydata
        self.xlim = [min(self.xPress,self.xRelease),max(self.xPress,self.xRelease)]
        self.ylim = [ min(self.yPress,self.yRelease),max(self.yPress,self.yRelease)]
        print "rect_select_callback:",self.xlim,self.ylim
        self.draw(setlim=False)

    def onZoomInBtn(self,event):       
        self.figure.RS.set_active(True)

    def onZoomOutBtn(self,event):
        self.draw()

    def onPrintBtn(self,event):
        filename = self.title.replace(" ", "").replace("=","")+".png"
        os.system('rm -rf ./Figures/'+filename)
        try:
            os.makedirs('./Figures')
        except:
            pass
        self.figure.savefig('./Figures/'+filename, dpi=self.figure.dpi)

    def draw(self, setlim=True):
        if setlim:
            self.xlim = [np.min(self.x), np.max(self.x)]
            self.ylim = [np.min(self.y), np.max(self.y)]
        title=self.title
        plotCurv(self,x=self.x,y=self.y,title=title,xlabel=self.xlabel, \
            ylabel=self.ylabel,xlim=self.xlim, ylim=self.ylim)
        self.canvas.draw()
        self.canvas.Refresh()
        self.Show()

########################################################################

class CrocoGui(wx.Frame):

    def __init__(self):

        wx.Frame.__init__(self, None, wx.ID_ANY, title='My Form')

        self.Panel = wx.Panel(self, wx.ID_ANY)

        self.OpenFileBtn = wx.Button(self.Panel, wx.ID_ANY, "Open History File ...")
        self.OpenFileBtn.Bind(wx.EVT_BUTTON, self.onOpenFile)
        self.OpenFileTxt = wx.StaticText(self.Panel, wx.ID_ANY, " ", style=wx.ALIGN_LEFT)

        self.CrocoVariableChoice = wx.Choice(self.Panel, wx.ID_ANY, choices=["Croco Variables ..."])
        self.CrocoVariableChoice.SetSelection(0)
        self.CrocoVariableChoice.Bind(wx.EVT_CHOICE, self.onCrocoVariableChoice)

        self.DerivedVariableChoice = wx.Choice(self.Panel, wx.ID_ANY, choices=["Derived Variables ..."])
        self.DerivedVariableChoice.SetSelection(0)
        self.DerivedVariableChoice.Bind(wx.EVT_CHOICE, self.onDerivedVariableChoice)

        self.ResetColorBtn = wx.Button(self.Panel, wx.ID_ANY, "Reset Color")
        self.ResetColorBtn.Bind(wx.EVT_BUTTON, self.onResetColorBtn)
        self.MinColorTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "Min Color", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.MinColorTxt.Bind(wx.EVT_TEXT_ENTER, self.onMinColorTxt)
        self.MaxColorTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "Max Color", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.MaxColorTxt.Bind(wx.EVT_TEXT_ENTER, self.onMaxColorTxt)

        self.LabelTime = wx.StaticText(self.Panel,-1,label="Choose Time",style = wx.ALIGN_CENTER)
        self.LabelMinMaxTime = wx.StaticText(self.Panel, wx.ID_ANY, " ", style=wx.ALIGN_LEFT)
        self.TimeMinusBtn = wx.Button(self.Panel, wx.ID_ANY, "<")
        self.TimeMinusBtn.Bind(wx.EVT_BUTTON, self.onTimeMinusBtn)
        self.TimeTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "Time", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.TimeTxt.Bind(wx.EVT_TEXT_ENTER, self.onTimeTxt)
        self.TimePlusBtn = wx.Button(self.Panel, wx.ID_ANY, ">")
        self.TimePlusBtn.Bind(wx.EVT_BUTTON, self.onTimePlusBtn)

        self.LabelLevel = wx.StaticText(self.Panel,-1,label="Choose level (level>0, depth<0)",style = wx.ALIGN_CENTER)
        self.LabelMinMaxLevel = wx.StaticText(self.Panel, wx.ID_ANY, " ", style=wx.ALIGN_LEFT)
        self.LabelMinMaxDepth = wx.StaticText(self.Panel, wx.ID_ANY, " ", style=wx.ALIGN_LEFT)
        self.LevelMinusBtn = wx.Button(self.Panel, wx.ID_ANY, "<")
        self.LevelMinusBtn.Bind(wx.EVT_BUTTON, self.onLevelMinusBtn)
        self.LevelTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "Level", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.LevelTxt.Bind(wx.EVT_TEXT_ENTER, self.onLevelTxt)
        self.LevelPlusBtn = wx.Button(self.Panel, wx.ID_ANY, ">")
        self.LevelPlusBtn.Bind(wx.EVT_BUTTON, self.onLevelPlusBtn)

        self.LonSectionBtn = wx.Button(self.Panel, wx.ID_ANY, "Longitude Section")
        self.LonSectionBtn.Bind(wx.EVT_BUTTON, self.onLonSectionBtn)
        self.LonSectionTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "Longitude", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.LonSectionTxt.Bind(wx.EVT_TEXT_ENTER, self.onLonSectionTxt)
        self.LatSectionBtn = wx.Button(self.Panel, wx.ID_ANY, "Latitude Section")
        self.LatSectionBtn.Bind(wx.EVT_BUTTON, self.onLatSectionBtn)
        self.LatSectionTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "Latitude", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.LatSectionTxt.Bind(wx.EVT_TEXT_ENTER, self.onLatSectionTxt)
        self.HovmullerBtn = wx.Button(self.Panel, wx.ID_ANY, "Hovmuller")
        self.HovmullerBtn.Bind(wx.EVT_BUTTON, self.onHovmullerBtn)
        self.TimeSeriesBtn = wx.Button(self.Panel, wx.ID_ANY, "Time Series")
        self.TimeSeriesBtn.Bind(wx.EVT_BUTTON, self.onTimeSeriesBtn)
        self.VerticalProfileBtn = wx.Button(self.Panel, wx.ID_ANY, "Vertical Profile")
        self.VerticalProfileBtn.Bind(wx.EVT_BUTTON, self.onVerticalProfileBtn)


        # self.PanelCanvas = wx.Panel(self.Panel, wx.ID_ANY)
        self.PanelCanvas = wx.Panel(self.Panel, -1)
        self.figure = Figure(figsize=(figsize[0],figsize[1]))
        # self.figure.canvas.mpl_connect('button_press_event', self.onFigureClick)
        self.canvas = FigureCanvas(self.PanelCanvas, -1, self.figure)
        # self.canvas.mpl_connect('button_press_event', self.onFigureClick)
        # self.canvas.mpl_connect('button_release_event', self.onFigureRelease)
        # self.axes = self.figure.add_axes([0,0,1,1])
        # self.axes = self.figure.add_axes([0.1,0.1,0.9,0.9])

        self.AnimationBtn = wx.Button(self.Panel, wx.ID_ANY, "Animation")
        self.AnimationBtn.Bind(wx.EVT_BUTTON, self.onAnimationBtn)
        self.startTimeTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "1", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.startTimeTxt.Bind(wx.EVT_TEXT_ENTER, self.onstartTimeTxt)
        self.endTimeTxt = wx.TextCtrl(self.Panel, wx.ID_ANY, "1", style=wx.TE_CENTRE|wx.TE_PROCESS_ENTER)
        self.endTimeTxt.Bind(wx.EVT_TEXT_ENTER, self.onendTimeTxt)
        self.ZoomInBtn = wx.Button(self.Panel, wx.ID_ANY, "Zoom In")
        self.ZoomInBtn.Bind(wx.EVT_BUTTON, self.onZoomInBtn)
        self.ZoomOutBtn = wx.Button(self.Panel, wx.ID_ANY, "Zoom Out")
        self.ZoomOutBtn.Bind(wx.EVT_BUTTON, self.onZoomOutBtn)
        self.PrintBtn = wx.Button(self.Panel, wx.ID_ANY, "Print")
        self.PrintBtn.Bind(wx.EVT_BUTTON, self.onPrintBtn)

        # self.__set_properties()
        self.__do_layout()

        self.sectionXY = SectionFrame()

        self.currentDirectory = os.getcwd()

    def __do_layout(self):

        topSizer        = wx.BoxSizer(wx.HORIZONTAL)
        leftSizer        = wx.BoxSizer(wx.VERTICAL)
        rightSizer        = wx.BoxSizer(wx.VERTICAL)
        openFileSizer   = wx.BoxSizer(wx.VERTICAL)
        chooseVariablesSizer = wx.BoxSizer(wx.HORIZONTAL)
        colorSizer      = wx.BoxSizer(wx.HORIZONTAL)
        labelTimeSizer  = wx.BoxSizer(wx.HORIZONTAL)
        labelMinMaxTimeSizer  = wx.BoxSizer(wx.HORIZONTAL)
        timeSizer       = wx.BoxSizer(wx.HORIZONTAL)
        labelLevelSizer  = wx.BoxSizer(wx.HORIZONTAL)
        labelMinMaxLevelSizer  = wx.BoxSizer(wx.HORIZONTAL)
        labelMinMaxDepthSizer  = wx.BoxSizer(wx.HORIZONTAL)
        levelSizer       = wx.BoxSizer(wx.HORIZONTAL)
        longitudeSizer  = wx.BoxSizer(wx.HORIZONTAL)
        latitudeSizer   = wx.BoxSizer(wx.HORIZONTAL)
        hovmullerSizer  = wx.BoxSizer(wx.HORIZONTAL)
        timeSeriesSizer = wx.BoxSizer(wx.HORIZONTAL)
        profileSizer   = wx.BoxSizer(wx.HORIZONTAL)
        canvasSizer     = wx.BoxSizer(wx.VERTICAL)
        buttonsSizer    = wx.BoxSizer(wx.HORIZONTAL)

        openFileSizer.Add(self.OpenFileBtn, 0, wx.ALL, 5)
        openFileSizer.Add(self.OpenFileTxt, 1, wx.ALL|wx.EXPAND, 5)
        chooseVariablesSizer.Add(self.CrocoVariableChoice, 0, wx.ALL, 5)
        chooseVariablesSizer.Add(self.DerivedVariableChoice, 0, wx.ALL, 5)

        colorSizer.Add(self.ResetColorBtn, 0, wx.ALL, 5)
        colorSizer.Add(self.MinColorTxt, 0, wx.ALL, 5)
        colorSizer.Add(self.MaxColorTxt, 0, wx.ALL, 5)

        labelTimeSizer.Add(self.LabelTime, 0, wx.ALL|wx.EXPAND, 5)
        labelMinMaxTimeSizer.Add(self.LabelMinMaxTime, 0, wx.ALL|wx.EXPAND, 5)
        timeSizer.Add(self.TimeMinusBtn, 0, wx.ALL, 5)
        timeSizer.Add(self.TimeTxt, 0, wx.ALL, 5)
        timeSizer.Add(self.TimePlusBtn, 0, wx.ALL, 5)

        labelLevelSizer.Add(self.LabelLevel, 0, wx.ALL|wx.EXPAND, 5)
        labelMinMaxLevelSizer.Add(self.LabelMinMaxLevel, 0, wx.ALL|wx.EXPAND, 5)
        labelMinMaxDepthSizer.Add(self.LabelMinMaxDepth, 0, wx.ALL|wx.EXPAND, 5)
        levelSizer.Add(self.LevelMinusBtn, 0, wx.ALL, 5)
        levelSizer.Add(self.LevelTxt, 0, wx.ALL, 5)
        levelSizer.Add(self.LevelPlusBtn, 0, wx.ALL, 5)

        longitudeSizer.Add(self.LonSectionBtn, 0, wx.ALL, 5)
        longitudeSizer.Add(self.LonSectionTxt, 0, wx.ALL, 5)

        latitudeSizer.Add(self.LatSectionBtn, 0, wx.ALL, 5)
        latitudeSizer.Add(self.LatSectionTxt, 0, wx.ALL, 5)

        hovmullerSizer.Add(self.HovmullerBtn, 0, wx.ALL, 5)

        timeSeriesSizer.Add(self.TimeSeriesBtn, 0, wx.ALL, 5)

        profileSizer.Add(self.VerticalProfileBtn, 0, wx.ALL, 5)

        canvasSizer.Add(self.PanelCanvas, 1, wx.EXPAND , 5)
        buttonsSizer.Add(self.AnimationBtn,0, wx.ALL, 5)
        buttonsSizer.Add(self.startTimeTxt,1, wx.ALL, 5)
        buttonsSizer.Add(self.endTimeTxt,1, wx.ALL, 5)
        buttonsSizer.Add(self.ZoomInBtn,0, wx.ALL, 5)
        buttonsSizer.Add(self.ZoomOutBtn,0, wx.ALL, 5)
        buttonsSizer.Add(self.PrintBtn,0, wx.ALL, 5)

        leftSizer.Add(openFileSizer, 0,wx.ALL|wx.EXPAND, 5 )
        leftSizer.Add(chooseVariablesSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(labelTimeSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(labelMinMaxTimeSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(timeSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(labelLevelSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(labelMinMaxLevelSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(labelMinMaxDepthSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(levelSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(longitudeSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(latitudeSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(hovmullerSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(timeSeriesSizer, 0, wx.ALL|wx.EXPAND, 5)
        leftSizer.Add(profileSizer, 0, wx.ALL|wx.EXPAND, 5)
        rightSizer.Add(canvasSizer, 0, wx.EXPAND)
        rightSizer.Add(buttonsSizer, 0, wx.ALL|wx.EXPAND, 5)
        rightSizer.Add(colorSizer, 0, wx.ALL|wx.EXPAND, 5)

        topSizer.Add(leftSizer, 0,wx.ALL|wx.EXPAND, 5 )
        # topSizer.Add(rightSizer, 0,wx.ALL|wx.EXPAND, 5 )
        topSizer.Add(rightSizer, 0,wx.EXPAND, 5 )

        self.Panel.SetSizer(topSizer)
        self.Panel.SetAutoLayout(True)
        topSizer.Fit(self)

        # self.SetAutoLayout(True)
        # self.SetSizer(topSizer)

        self.Layout()


    def onOpenFile(self, event):
        """
        Create and show the Open FileDialog
        """
        dlg = wx.FileDialog(
            self, message="Choose a file",
            defaultDir=self.currentDirectory, 
            defaultFile="",
            wildcard=wildcard,
            style=wx.FD_OPEN | wx.FD_MULTIPLE | wx.FD_CHANGE_DIR
            )
        if dlg.ShowModal() == wx.ID_OK:
            paths = dlg.GetPaths()
        dlg.Destroy()
        self.croco = Croco(paths[0]) 
        # self.OpenFileTxt.SetLabel(paths[0]) 
        timeMin = self.croco.wrapper._get_date(0)
        timeMax = self.croco.wrapper._get_date(self.croco.wrapper.ntimes-1)
        self.LabelMinMaxTime.SetLabel("Min/Max Time = "+str(timeMin)+" ... "+str(timeMax)+ "days") 
        self.TimeTxt.SetValue(str(timeMin))
        self.timeIndex = 0
        self.time = timeMin
        minLevel = 1
        maxLevel = int(self.croco.wrapper.N)
        minDepth = - int(self.croco.wrapper.metrics['h'].max())
        maxDepth = 0
        self.LabelMinMaxLevel.SetLabel("Min/Max Level = 1 ... "+ str(maxLevel))
        self.LabelMinMaxDepth.SetLabel("Min/Max Depth = "+ str(minDepth)+" ... "+str(maxDepth))
        self.levelIndex=self.croco.wrapper.N - 1
        self.LevelTxt.SetValue(str(self.levelIndex+1))
        self.depth = self.levelIndex + 1
        self.startTimeTxt.SetValue(str(timeMin))
        self.startTime = timeMin
        self.startTimeIndex = 0
        self.endTimeTxt.SetValue(str(timeMax))
        self.endTime = timeMax
        self.endTimeIndex = self.croco.wrapper.ntimes -1
        self.CrocoVariableChoice.AppendItems(self.croco.ListOfVariables)


    def onFigureClick(self,event):
        self.lon, self.lat = event.xdata, event.ydata
        self.latIndex,self.lonIndex = self.findLatLonIndex(self.lon, self.lat)
        self.LonSectionTxt.SetValue('%.2F' % self.lon)
        self.LatSectionTxt.SetValue('%.2F' % self.lat)

    # def onFigureRelease(self,event):
    #     self.lonRelease, self.latRelease = event.xdata, event.ydata
    #     self.lonReleaseIndex,self.latReleaseIndex = self.findLatLonIndex(self.lonRelease, self.latRelease)

    def rect_select_callback(self, eclick, erelease):
        self.xPress, self.yPress = eclick.xdata, eclick.ydata
        self.xRelease, self.yRelease = erelease.xdata, erelease.ydata
        self.xlim = [min(self.xPress,self.xRelease),max(self.xPress,self.xRelease)]
        self.ylim = [ min(self.yPress,self.yRelease),max(self.yPress,self.yRelease)]
        self.drawxy(setlim=False)
        print('rect_select_callback:',self.xPress, self.yPress,self.xRelease, self.yRelease)
    #     print(" The button you used were: %s %s" % (eclick.button, erelease.button))

    def findLatLonIndex(self, lonValue, latValue):
        ''' Find nearest value is an array '''
        a = abs(self.croco.wrapper.coords['lon_r'].values - lonValue) + \
            abs(self.croco.wrapper.coords['lat_r'].values - latValue)
        return np.unravel_index(a.argmin(),a.shape)

    def onCrocoVariableChoice(self, event):
        '''
        Choose variable to plot, update text zone for color, launch plot
        '''
        self.variableName = self.CrocoVariableChoice.GetString(self.CrocoVariableChoice.GetSelection())
        time = str(self.timeIndex)
        level = str(self.levelIndex)
        try:
            self.variableXY = self.croco.variables[self.variableName].isel(t=self.timeIndex,z_r=self.levelIndex)
        except:
            self.variableXY = self.croco.variables[self.variableName].isel(t=self.timeIndex)

        self.mincolor = np.min(self.variableXY.values)
        self.MinColorTxt.SetValue('%.2E' % self.mincolor)
        self.maxcolor = np.max(self.variableXY.values)
        self.MaxColorTxt.SetValue('%.2E' % self.maxcolor)
        self.clim = [self.mincolor,self.maxcolor]
        self.xlim = [np.min(self.croco.wrapper.coords['lon_r'].values), \
                     np.max(self.croco.wrapper.coords['lon_r'].values)]
        self.ylim = [np.min(self.croco.wrapper.coords['lat_r'].values), \
                     np.max(self.croco.wrapper.coords['lat_r'].values)]
        self.drawxy()

    def onDerivedVariableChoice(self, event):
        self.variableName = self.DerivedVariableChoice.GetString(self.DerivedVariableChoice.GetSelection())
        # time = str(self.timeIndex)
        # level = str(self.levelIndex)
        # self.variableXY = self.croco.read_nc(self.variableName, indices= "["+time+","+level+",:,:]")
        # self.draw()

    def onResetColorBtn(self,event):
        self.clim = [np.min(self.variableXY.values),np.max(self.variableXY.values)]
        self.MinColorTxt.SetValue('%.2E' % self.clim[0])
        self.MaxColorTxt.SetValue('%.2E' % self.clim[1])
        self.drawxy()

    def onMinColorTxt(self,event):
        self.clim[0] = float(self.MinColorTxt.GetValue())
        self.drawxy(setlim=False)

    def onMaxColorTxt(self,event):
        self.clim[1] = float(self.MaxColorTxt.GetValue())
        self.drawxy(setlim=False)


    def onTimeMinusBtn(self,event):
        self.timeIndex = max(self.timeIndex - 1,0)
        self.time = self.croco.wrapper._get_date(self.timeIndex)
        self.TimeTxt.SetValue(str(self.time))
        self.updateVariableXY()
        self.drawxy()

    def onTimePlusBtn(self,event):
        self.timeIndex = min(self.timeIndex + 1,self.croco.wrapper.ntimes - 1)
        self.time = self.croco.wrapper._get_date(self.timeIndex)
        self.TimeTxt.SetValue(str(self.time))
        self.updateVariableXY()
        self.drawxy()

    def onTimeTxt(self,event):
        # !!! il faut saisir un float, à améliorer
        time = float(self.TimeTxt.GetValue())
        times = self.croco.wrapper.coords['time'].values
        # find index corresponding to the nearest instant time to plot
        self.timeIndex = min( range( len(times) ), \
            key=lambda j:abs(time-times[j]))
        self.time = self.croco.wrapper._get_date(self.timeIndex)
        self.TimeTxt.SetValue(str(self.time))
        self.updateVariableXY()
        self.drawxy()

    def onLevelMinusBtn(self,event):
        self.levelIndex = max(self.levelIndex - 1,0)
        self.depth = self.levelIndex + 1
        self.LevelTxt.SetValue(str(self.levelIndex + 1))
        self.updateVariableXY()
        self.drawxy()

    def onLevelPlusBtn(self,event):
        self.levelIndex = min(self.levelIndex + 1,self.croco.wrapper.N - 1)
        self.depth = self.levelIndex + 1
        self.LevelTxt.SetValue(str(self.levelIndex + 1))
        self.updateVariableXY()
        self.drawxy()

    def onLevelTxt(self,event):
        time = str(self.timeIndex)
        depth = float(self.LevelTxt.GetValue())
        if depth > 0:
            self.levelIndex = int(self.LevelTxt.GetValue()) - 1
            self.depth = self.levelIndex + 1
            self.updateVariableXY()
        elif depth < 0:
            self.depth = depth
            # Calculate depths 
            ssh = self.croco.variables['ssh'].isel(t=self.timeIndex).values
            if self.variableName=="u":
                z = self.croco.wrapper.scoord2z_u(ssh, alpha=0., beta=0)
            elif self.variableName=="v":
                z = self.croco.wrapper.scoord2z_v(ssh, alpha=0., beta=0)
            else :
                z = self.croco.wrapper.scoord2z_r(ssh, alpha=0., beta=0)
            minlev,maxlev = self.croco.zslice(None,self.croco.wrapper.masks['mask_r'],z,depth,findlev=True)
            var = self.croco.variables[self.variableName].isel(t=self.timeIndex, z_r=slice(minlev,maxlev+1))
            dims = self.croco.variables[self.variableName].dims
            mask = self.croco.wrapper.masks['mask_r']
            if "x_u" in dims:
                mask = self.croco.rho2u_2d(mask)
            elif "y_v" in dims:
                mask = self.croco.rho2v_2d(mask)
            zslice = self.croco.zslice(var.values,mask,z[minlev:maxlev+1,:,:],depth)[0]
            self.variableXY = xr.DataArray(data=zslice)
        else:
            print "baraotrope"
        self.drawxy()

    def onLonSectionBtn(self,event):
        # if variable without z dimension
        if len(self.croco.variables[self.variableName].dims) < 4 :
            return
        # Get longitude section of current variable
        # variableZ = self.croco.get_variable(self.variableName, tindex=self.timeIndex, \
        #     xindex=self.lonIndex)
        variable = self.croco.get_variable(self.variableName, \
            xindex=self.lonIndex)
        # Get Latitude coordinates
        x = self.croco.get_coord(self.variableName, direction='y')
        x = repmat(x[:,self.lonIndex].squeeze(),self.croco.wrapper.N,1)
        # Calculate depths of the slice
        ssh = self.croco.variables['ssh'].isel(t=self.timeIndex).values
        if self.variableName=="u":
            y = self.croco.wrapper.scoord2z_u(ssh, alpha=0., beta=0)[:,:,self.lonIndex]
        elif self.variableName=="v":
            y = self.croco.wrapper.scoord2z_v(ssh, alpha=0., beta=0)[:,:,self.lonIndex]
        else :
            y = self.croco.wrapper.scoord2z_r(ssh, alpha=0., beta=0)[:,:,self.lonIndex]
        self.sectionYZ = SectionFrame(\
            croco=self.croco, \
            variableName = self.variableName, \
            variable=variable, 
            x=x, y=y, \
            typSection="YZ" , \
            sliceCoord = self.lon, \
            timeIndex=self.timeIndex)
        # Draw the plot
        self.sectionYZ.updateVariableZ()



    def onLonSectionTxt(self,event):
        # if variable without z dimension
        if len(self.croco.variables[self.variableName].dims) < 4 :
            return
        self.lon = float(self.LonSectionTxt.GetValue())
        self.latIndex,self.lonIndex = self.findLatLonIndex(self.lon, self.lat) 

        # Get longitude section of current variable
        # variableZ = self.croco.get_variable(self.variableName, tindex=self.timeIndex, \
        #     xindex=self.lonIndex)
        variable = self.croco.get_variable(self.variableName, \
            xindex=self.lonIndex)
        # Get Latitude coordinates
        x = self.croco.get_coord(self.variableName, direction='y')
        x = repmat(x[:,self.lonIndex].squeeze(),self.croco.wrapper.N,1)
        # Calculate depths of the slice
        ssh = self.croco.variables['ssh'].isel(t=self.timeIndex).values
        if self.variableName=="u":
            y = self.croco.wrapper.scoord2z_u(ssh, alpha=0., beta=0)[:,:,self.lonIndex]
        elif self.variableName=="v":
            y = self.croco.wrapper.scoord2z_v(ssh, alpha=0., beta=0)[:,:,self.lonIndex]
        else :
            y = self.croco.wrapper.scoord2z_r(ssh, alpha=0., beta=0)[:,:,self.lonIndex]
        self.sectionYZ = SectionFrame(\
            croco=self.croco, \
            variableName = self.variableName, \
            variable=variable, 
            x=x, y=y, \
            typSection="YZ" , \
            sliceCoord = self.lon, \
            timeIndex=self.timeIndex)
        # Draw the plot
        self.sectionYZ.updateVariableZ()


    def onLatSectionBtn(self,event):
        # if variable without z dimension
        if len(self.croco.variables[self.variableName].dims) < 4 :
            return
        # Get latitude section of current variable
        variable = self.croco.get_variable(self.variableName, \
            yindex=self.latIndex)
        # Get Latitude coordinates
        x = self.croco.get_coord(self.variableName, direction='x')
        x = repmat(x[self.latIndex,:].squeeze(),self.croco.wrapper.N,1)
        # Calculate depths of the slice
        ssh = self.croco.variables['ssh'].isel(t=self.timeIndex).values
        if self.variableName=="u":
            y = self.croco.wrapper.scoord2z_u(ssh, alpha=0., beta=0)[:,self.latIndex,:]
        elif self.variableName=="v":
            y = self.croco.wrapper.scoord2z_v(ssh, alpha=0., beta=0)[:,self.latIndex,:]
        else :
            y = self.croco.wrapper.scoord2z_r(ssh, alpha=0., beta=0)[:,self.latIndex,:]
        self.sectionXZ = SectionFrame(\
            croco=self.croco, \
            variableName = self.variableName, \
            variable=variable, 
            x=x, y=y, \
            typSection="XZ" , \
            sliceCoord = self.lat, \
            timeIndex=self.timeIndex)
        # Draw the plot
        self.sectionXZ.updateVariableZ()


    def onLatSectionTxt(self,event):
        # if variable without z dimension
        if len(self.croco.variables[self.variableName].dims) < 4 :
            return
        self.lat = float(self.LatSectionTxt.GetValue())
        self.latIndex,self.lonIndex = self.findLatLonIndex(self.lon, self.lat) 
        # Get latitude section of current variable
        variable = self.croco.get_variable(self.variableName, \
            yindex=self.latIndex)
        # Get Latitude coordinates
        x = self.croco.get_coord(self.variableName, direction='x')
        x = repmat(x[self.latIndex,:].squeeze(),self.croco.wrapper.N,1)
        # Calculate depths of the slice
        ssh = self.croco.variables['ssh'].isel(t=self.timeIndex).values
        if self.variableName=="u":
            y = self.croco.wrapper.scoord2z_u(ssh, alpha=0., beta=0)[:,self.latIndex,:]
        elif self.variableName=="v":
            y = self.croco.wrapper.scoord2z_v(ssh, alpha=0., beta=0)[:,self.latIndex,:]
        else :
            y = self.croco.wrapper.scoord2z_r(ssh, alpha=0., beta=0)[:,self.latIndex,:]
        self.sectionXZ = SectionFrame(\
            croco=self.croco, \
            variableName = self.variableName, \
            variable=variable, 
            x=x, y=y, \
            typSection="XZ" , \
            sliceCoord = self.lat, \
            timeIndex=self.timeIndex)
        # Draw the plot
        self.sectionXZ.updateVariableZ()



    def onHovmullerBtn(self,event):
        print("Hovmuller not implemented yet!!!")

    def onTimeSeriesBtn(self,event):
        x = self.croco.wrapper.coords['time'].values.astype('timedelta64[D]').astype('float')
        y = self.croco.get_variable(self.variableName, \
            xindex=self.lonIndex, yindex=self.latIndex, zindex=self.levelIndex).values
        # try:
        #     self.profileFrame.IsShown()
        # except Exc
        title="{:s}, Lon={:4.1f}, Lat={:4.1f}, Depth={:4.0f}".\
            format(self.variableName,self.lon,self.lat, self.depth)    
        self.timeFrame = ProfileFrame(croco=self.croco, \
            x=x, y=y, \
            variableName=self.variableName, \
            title=title, \
            xlabel="Time (days)")
        self.timeFrame.draw()

    def onVerticalProfileBtn(self,event):
        if len(self.croco.variables[self.variableName].dims) < 4 :
            return
        time = str(self.croco.wrapper._get_date(self.timeIndex))
        title="{:s}, Lon={:4.1f}, Lat={:4.1f}, Time={:s}".\
            format(self.variableName,self.lon,self.lat,time)
        # Calculate depths of the slice
        ssh = self.croco.variables['ssh'].isel(t=self.timeIndex).values
        if self.variableName=="u":
            z = self.croco.wrapper.scoord2z_u(ssh, alpha=0., beta=0)[:,self.latIndex,self.lonIndex]
        elif self.variableName=="v":
            z = self.croco.wrapper.scoord2z_v(ssh, alpha=0., beta=0)[:,self.latIndex,self.lonIndex]
        else :
            z = self.croco.wrapper.scoord2z_r(ssh, alpha=0., beta=0)[:,self.latIndex,self.lonIndex]

        x = self.croco.get_variable(self.variableName, \
            xindex=self.lonIndex, yindex=self.latIndex, tindex=self.timeIndex).values
        # try:
        #     self.profileFrame.IsShown()
        # except:
        self.profileFrame = ProfileFrame(croco=self.croco, \
            x=x, y=z, \
            variableName=self.variableName, \
            title=title,
            ylabel="Depth (m)")
        self.profileFrame.draw()

    def onAnimationBtn(self,event):
        os.system('rm -rf ./Figures/'+self.variableName+'.mp4')
        try:
            os.makedirs('./Figures')
        except:
            pass
        self.clim = [np.min(self.variableXY),np.max(self.variableXY)]
        save_count = self.endTimeIndex - self.startTimeIndex + 1
        anim = animation.FuncAnimation(self.figure, self.animate, \
                   frames = range(self.startTimeIndex,self.endTimeIndex+1), repeat=False, \
                   blit = False, save_count=save_count)
        self.canvas.draw()
        time1 = str(self.croco.wrapper._get_date(self.startTimeIndex))
        time2 = str(self.croco.wrapper._get_date(self.endTimeIndex))
        filename = "{:s}_Depth={:4.0f}_{:s}-{:s}.mp4".format(self.variableName,self.depth,time1,time2)
        filename=filename.replace(" ","")
        anim.save('./Figures/'+filename)

    def animate( self, i):
        self.timeIndex = i
        self.updateVariableXY(setlim=False)

    def onstartTimeTxt(self,event):
        # !!! il faut saisir un float, à améliorer
        # self.startTime = np.timedelta64(self.startTimeTxt.GetValue(),'D')
        self.startTime = float(self.startTimeTxt.GetValue())
        times = self.croco.wrapper.coords['time'].values
        # find index corresponding to instant time to plot
        # self.timeIndex = min( range( len(self.croco.wrapper.coords['time'].values) ), \
        #     key=lambda j:abs(time-self.croco.wrapper.coords['time'].values[j]))
        self.startTimeIndex = min( range( len(times) ), \
            key=lambda j:abs(self.startTime-times[j]))
        # self.startTime = float(self.startTimeTxt.GetValue())
        # find index corresponding to instant time to plot
        # self.startTimeIndex = min( range( len(self.croco.wrapper.coords['time'].values) ), \
        #            key=lambda j:abs(self.startTime-self.croco.wrapper.coords['time'].values[j]))
        self.startTime = self.croco.wrapper._get_date(self.startTimeIndex)
        self.startTimeTxt.SetValue(str(self.startTime))

    def onendTimeTxt(self,event):
        # !!! il faut saisir un float, à améliorer
        # self.endTime = np.timedelta64(self.endTimeTxt.GetValue(),'D')
        self.endTime = float(self.endTimeTxt.GetValue())
        times = self.croco.wrapper.coords['time'].values
        # self.startTime = float(self.startTimeTxt.GetValue())
        # find index corresponding to instant time to plot
        self.endTimeIndex = min( range( len(times) ), \
            key=lambda j:abs(self.endTime-times[j]))
        # self.endTimeIndex = min( range( len(self.croco.wrapper.coords['time'].values) ), \
        #            key=lambda j:abs(self.endTime-self.croco.wrapper.coords['time'].values[j]))
        self.endTime = self.croco.wrapper._get_date(self.endTimeIndex)
        self.endTimeTxt.SetValue(str(self.endTime))


    def rect_select_callback(self, eclick, erelease):
        self.xPress, self.yPress = eclick.xdata, eclick.ydata
        self.xRelease, self.yRelease = erelease.xdata, erelease.ydata
        self.xlim = [min(self.xPress,self.xRelease),max(self.xPress,self.xRelease)]
        self.ylim = [ min(self.yPress,self.yRelease),max(self.yPress,self.yRelease)]
        self.drawxy(setlim=False)
    #     print(" The button you used were: %s %s" % (eclick.button, erelease.button))

    def onZoomInBtn(self,event):
        self.figure.RS.set_active(True)

    def onZoomOutBtn(self,event):
        self.xlim = [np.min(self.croco.wrapper.coords['lon_r'].values), \
                     np.max(self.croco.wrapper.coords['lon_r'].values)]
        self.ylim = [np.min(self.croco.wrapper.coords['lat_r'].values), \
                     np.max(self.croco.wrapper.coords['lat_r'].values)]
        self.drawxy()

    def onPrintBtn(self,event):
        time = str(self.croco.wrapper._get_date(self.timeIndex))
        filename = "{:s}_Depth={:4.0f}_Time{:s}".format(self.variableName,self.depth,time)
        filename=filename.replace(" ","")+".png"
        os.system('rm -rf ./Figures/'+filename)
        try:
            os.makedirs('./Figures')
        except:
            pass
        self.figure.savefig('./Figures/'+filename, dpi=self.figure.dpi)

    def updateVariableXY(self,setlim=True):
        try:
            self.variableXY = self.croco.variables[self.variableName].isel(t=self.timeIndex,z_r=self.levelIndex)
        except:
            self.variableXY = self.croco.variables[self.variableName].isel(t=self.timeIndex)
        self.drawxy(setlim=setlim)


    def drawxy(self,setlim=True):
        self.figure.clf()
        # self.canvas.Destroy()
        # self.figure = Figure(figsize=(figsize[0],figsize[1]))
        # self.canvas = FigureCanvas(self.PanelCanvas, -1, self.figure)
        self.canvas.mpl_connect('button_press_event', self.onFigureClick)
        # self.canvas.mpl_connect('button_release_event', self.onFigureRelease)

        if setlim:
            self.mincolor = np.min(self.variableXY.values)
            self.MinColorTxt.SetValue('%.2E' % self.mincolor)
            self.maxcolor = np.max(self.variableXY.values)
            self.MaxColorTxt.SetValue('%.2E' % self.maxcolor)
            self.clim = [self.mincolor,self.maxcolor]
            self.xlim = [np.min(self.croco.wrapper.coords['lon_r'].values), \
                         np.max(self.croco.wrapper.coords['lon_r'].values)]
            self.ylim = [np.min(self.croco.wrapper.coords['lat_r'].values), \
                         np.max(self.croco.wrapper.coords['lat_r'].values)]


        time = str(self.croco.wrapper._get_date(self.timeIndex))
        depth = float(self.LevelTxt.GetValue())
        lon = self.croco.wrapper.coords['lon_r'].values
        lat = self.croco.wrapper.coords['lat_r'].values

        if depth > 0:
            title = "{:s}, Level={:4d}, Time={:s}".format(self.variableName,self.levelIndex+1,time)
        else:
            # title = "{:s}, Depth={:4.1f}, Time={:4.1f}".format(self.variableName,depth,time)
            title = "{:s}, Depth={:4.1f}, Time={:s}".format(self.variableName,depth,time)
        mypcolor(self,lon,lat,self.variableXY.values,\
                      title=title,\
                      xlabel='Longitude',\
                      ylabel='Latitude',\
                      xlim=self.xlim,\
                      ylim=self.ylim,\
                      clim=self.clim)
        
        self.canvas.draw()
        self.canvas.Refresh()
        self.Refresh()


# end of class CrocoGui



# Run the program
if __name__ == "__main__":
    app = wx.App(False)
    frame = CrocoGui()
    frame.Show()
    app.MainLoop()
# -*- coding: UTF-8 -*-
#
# generated by wxGlade 0.8.0b3 on Tue Jan 30 13:49:27 2018
#

import os
import wx
import numpy as np
import netCDF4 as netcdf
from scipy import interpolate

second2day = 1. /86400.

class Croco(object):
    '''
    Croco class
    '''
    def __init__(self, crocofile):
        '''
        Initialise the Croco object
        '''
        msg = '--- instantiating *%s*' % (crocofile)
        # print(bcolors.OKGREEN + msg + bcolors.ENDC)
        self.crocofile = crocofile
        self.r_earth = 6371315. # Mean earth radius in metres (from scalars.h)
        
        # An index along either x or y dimension
        self.ij = None

        self.crocoGrid = CrocoGrid(self.crocofile)

        self.ListOfVariables = self.list_of_variables()
        self.times = self.read_nc( "time_instant") * second2day


    def read_nc(self, varname, indices="[:]"):
        '''
        Read data from netcdf file
          varname : variable ('temp', 'mask_rho', etc) to read
          indices : string of index ranges, eg. '[0,:,0]'
        '''
        try:
            with netcdf.Dataset(self.crocofile) as nc:
                var = eval(''.join(("nc.variables[varname]", indices)))
        except Exception:
            try:
                with netcdf.Dataset(self.crocofile[0]) as nc:
                    var = eval(''.join(("nc.variables[varname]", indices)))
            except Exception:
                raise
        if 'float32' in var.dtype.name:
            return var.astype(np.float64)
        else:
            return var

    def read_nc_mf(self, varname, indices="[:]"):
        '''
        Read data from multi-file netcdf file
          varname : variable ('temp', 'mask_rho', etc) to read
          indices : string of index ranges, eg. '[0,:,0]'
        '''
        try:
            try:
                with netcdf.MFDataset(self.filenames) as nc:
                    var =  eval(''.join(("nc.variables[varname]", indices)))
            except Exception:
                with netcdf.MFDataset(self.filenames, aggdim='TIME') as nc:
                    var =  eval(''.join(("nc.variables[varname]", indices)))
        except Exception:
            raise
        if 'float32' in var.dtype.name:
            return var.astype(np.float64)
        else:
            return var


    def read_nc_at_index(self, varname, ind):
        '''
        Read data from multi-file netcdf file
          varname : variable ('temp', 'mask_rho', etc) to read
          indices : string of index ranges, eg. '[0,:,0]'
        '''
        try:
            with netcdf.Dataset(self.crocofile) as nc:
                return eval(''.join(("nc.variables[varname]", indices)))
        except Exception:
            try:
                with netcdf.Dataset(self.crocofile[0]) as nc:
                    return eval(''.join(("nc.variables[varname]", indices)))
            except Exception:
                raise Exception

    def read_nc_att(self, varname, att):
        '''
        Read data attribute from netcdf file
          varname : variable ('temp', 'mask_rho', etc) to read
          att : string of attribute, eg. 'valid_range'
        '''
        try:
            with netcdf.Dataset(self.crocofile) as nc:
                return eval(''.join(("nc.variables[varname].", att)))
        except Exception:
            try:
                with netcdf.Dataset(self.crocofile[0]) as nc:
                    return eval(''.join(("nc.variables[varname].", att)))
            except Exception:
                raise Exception

    def read_dim_size(self, dim):
        '''
        Read dimension size from netcdf file
          dim : dimension ('time', 'lon_u', etc) to read
        '''
        try:
            with netcdf.Dataset(self.crocofile) as nc:
                #return len(eval("nc.dimensions[dim]"))
                return len(nc.dimensions[dim])
        except Exception:
            raise


    def read_var_dim(self, varname):
        '''
        Read data from netcdf file
          varname : variable ('temp', 'mask_rho', etc) to read
          indices : string of index ranges, eg. '[0,:,0]'
        '''
        try:
            with netcdf.Dataset(self.crocofile) as nc:
                dims = nc.variables[varname].dimensions
        except Exception:
            try:
                with netcdf.Dataset(self.crocofile[0]) as nc:
                    dims = nc.variables[varname].dimensions
            except Exception:
                raise
        return dims

    def list_of_variables(self):
        '''
        '''
        crocofile = self.crocofile
        if isinstance(crocofile, list):
            crocofile = crocofile[0]
        not_done = True
        keys = []
        while not_done:
            try:
                with netcdf.Dataset(crocofile) as nc:
                    not_done = False
                    for var in nc.variables.keys():
                        liste = nc.variables[var].dimensions
                        if 'time_counter' in nc.variables[var].dimensions and \
                            len(nc.variables[var].dimensions)>2:
                            keys.append(var)
            except:
                time.sleep(0.5)
        return keys

    def get_run_name(self):
        index = self.crocofile.find("/CROCO_FILES")
        if index == -1:
            self.runName = ''
        else:
            self.runName = os.path.basename(os.path.dirname(self.crocofile[:index]))
        return self.runName

    @staticmethod
    def half_interp(h_one, h_two):
        '''
        Speed up frequent operations of type 0.5 * (arr[:-1] + arr[1:])
        '''
        return ne.evaluate('0.5 * (h_one + h_two)')


    @staticmethod
    def rho2u_2d(rho_in):
        '''
        Convert a 2D field at rho points to a field at u points
        '''
        def _r2u(rho_in, Lp):
            u_out = rho_in[:, :Lp - 1]
            u_out += rho_in[:, 1:Lp]
            u_out *= 0.5
            return u_out.squeeze()
        assert rho_in.ndim == 2, 'rho_in must be 2d'
        Mshp, Lshp = rho_in.shape
        return _r2u(rho_in, Lshp)

    @staticmethod
    def rho2u_3d(rho_in):
        '''
        Convert a 3D field at rho points to a field at u points
        Calls rho2u_2d
        '''
        def levloop(rho_in):
            Nlevs, Mshp, Lshp = rho_in.shape
            rho_out = np.zeros((Nlevs, Mshp, Lshp-1))
            for k in xrange(Nlevs):
                 rho_out[k] = Croco.rho2u_2d(rho_in[k])
            return rho_out
        assert rho_in.ndim == 3, 'rho_in must be 3d'
        return levloop(rho_in)

    @staticmethod
    def rho2v_2d(rho_in):
        '''
        Convert a 2D field at rho points to a field at v points
        '''
        def _r2v(rho_in, Mp):
            v_out = rho_in[:Mp - 1]
            v_out += rho_in[1:Mp]
            v_out *= 0.5
            return v_out.squeeze()
        assert rho_in.ndim == 2, 'rho_in must be 2d'
        Mshp, Lshp = rho_in.shape
        return _r2v(rho_in, Mshp)

    @staticmethod
    def rho2v_3d(rho_in):
        '''
        Convert a 3D field at rho points to a field at v points
        Calls rho2v_2d
        '''
        def levloop(rho_in):
            Nlevs, Mshp, Lshp = rho_in.shape
            rho_out = np.zeros((Nlevs, Mshp-1, Lshp))
            for k in xrange(Nlevs):
                 rho_out[k] = Croco.rho2v_2d(rho_in[k])
            return rho_out
        assert rho_in.ndim == 3, 'rho_in must be 3d'
        return levloop(rho_in)


    @staticmethod
    def u2rho_2d(u_in):
        '''
        Convert a 2D field at u points to a field at rho points
        '''
        def _uu2ur(uu_in, Mp, Lp):
            L, Lm = Lp - 1, Lp - 2
            u_out = np.zeros((Mp, Lp))
            u_out[:, 1:L] = 0.5 * (u_in[:, 0:Lm] + \
                                   u_in[:, 1:L])
            u_out[:, 0] = u_out[:, 1]
            u_out[:, L] = u_out[:, Lm]
            return u_out.squeeze()

        assert u_in.ndim == 2, 'u_in must be 2d'
        Mp, Lp = u_in.shape
        return _uu2ur(u_in, Mp, Lp+1)

    @staticmethod
    def u2rho_3d(u_in):
        '''
        Convert a 3D field at u points to a field at rho points
        Calls u2rho_2d
        '''
        def _levloop(u_in):
            Nlevs, Mshp, Lshp = u_in.shape
            u_out = np.zeros((Nlevs, Mshp, Lshp+1))
            for Nlev in xrange(Nlevs):
                u_out[Nlev] = Croco.u2rho_2d(u_in[Nlev])
            return u_out
        assert u_in.ndim == 3, 'u_in must be 3d'
        return _levloop(u_in)

    @staticmethod
    def v2rho_2d(v_in):
        '''
        Convert a 2D field at v points to a field at rho points
        '''
        def _vv2vr(v_in, Mp, Lp):
            M, Mm = Mp - 1, Mp - 2
            v_out = np.zeros((Mp, Lp))
            v_out[1:M] = 0.5 * (v_in[:Mm] + \
                                   v_in[1:M])
            v_out[0] = v_out[1]
            v_out[M] = v_out[Mm]
            return v_out.squeeze()

        assert v_in.ndim == 2, 'v_in must be 2d'
        Mp, Lp = v_in.shape
        return _vv2vr(v_in, Mp+1, Lp)

    @staticmethod
    def v2rho_3d(v_in):
        '''
        Convert a 3D field at v points to a field at rho points
        Calls v2rho_2d
        '''
        def levloop(v_in):
            Nlevs, Mshp, Lshp = v_in.shape
            v_out = np.zeros((Nlevs, Mshp+1, Lshp))
            for Nlev in xrange(Nlevs):
                v_out[Nlev] = Croco.v2rho_2d(v_in[Nlev])
            return v_out
        assert v_in.ndim == 3, 'v_in must be 3d'
        return levloop(v_in)


    def rotate(self, u_in, v_in, **kwargs):
        """
        Rotate velocity vectors
        'angle' from gridfile
        """
        if kwargs.has_key('ob'):
            if kwargs['ob'] in 'east':
                angle = self.angle()[:,-1]
            elif kwargs['ob'] in 'west':
                angle = self.angle()[:,0]
            elif kwargs['ob'] in 'north':
                angle = self.angle()[-1]
            elif kwargs['ob'] in 'south':
                angle = self.angle()[0]
            else:
                raise Exception
        else:
            angle = self.angle()
        cosa = np.cos(kwargs['sign'] * angle)
        sina = np.sin(kwargs['sign'] * angle)
        u_out = (u_in * cosa) + (v_in * sina)
        v_out = (v_in * cosa) - (u_in * sina)
        return u_out, v_out


    def _get_barotropic_velocity(self, baroclinic_velocity, cell_depths):
        '''
        '''
        sum_baroclinic = (baroclinic_velocity * cell_depths).sum(axis=0)
        total_depth = cell_depths.sum(axis=0)
        sum_baroclinic /= total_depth
        return sum_baroclinic

    def get_barotropic_velocity(self, baroclinic_velocity, cell_depths):
        '''
        Input:
          baroclinic_velocity
          cell_depths
        '''
        return self._get_barotropic_velocity(baroclinic_velocity, cell_depths)


    def set_barotropic(self): #, open_boundary):
        '''
        '''
        self.barotropic = self._get_barotropic_velocity(self.dataout,
                                                        self.romsgrd.scoord2dz())
        return self


####################################################################################

class CrocoGrid (Croco):
    '''
    CrocoGrid class (inherits from Croco class)
    '''
    def __init__(self, crocofile):
        '''

        '''
        # super(CrocoGrid, self).__init__(filename)
        self.indices = '[self.j0:self.j1, self.i0:self.i1]'
        self.i0 = 0
        self.i1 = None
        self.j0 = 0
        self.j1 = None
        self.k = 0 # to be used as a z index
        self.t = 0 # to be used as a time index
        self.crocofile = crocofile
        with netcdf.Dataset(self.crocofile) as nc:
	        self._lon = self.read_nc('nav_lon_rho')#, indices=self.indices)
	        self._lat =  self.read_nc('nav_lat_rho')#, indices=self.indices)
	        self._pm = self.read_nc('pm')#, indices=self.indices)
	        self._pn = self.read_nc('pn')#, indices=self.indices)
	        self._maskr = self.read_nc('mask_rho')#, indices=self.indices)
	        self._angle = self.read_nc('angle')#, indices=self.indices)
	        self._h = self.read_nc('h')#, indices=self.indices)
	        # self._hraw = self.read_nc('hraw')#, indices=self.indices)
	        self._f = self.read_nc('f')#, indices=self.indices)
	        self._uvpmask()
	        self.theta_s = self.read_nc('theta_s')
	        self.theta_b = self.read_nc('theta_b')
	        self.hc = self.read_nc('hc')
	        self.L = self.read_dim_size("x_rho")
	        self.M = self.read_dim_size("y_rho")
	        self.N = self.read_dim_size("s_rho")
	        self.ntimes = self.read_dim_size("time_counter")
	        self.sc_r = self.read_nc('sc_r')


    def lon(self):   return self._lon[self.j0:self.j1, self.i0:self.i1]
    def lat(self):   return self._lat[self.j0:self.j1, self.i0:self.i1]
    def pm(self):    return self._pm[self.j0:self.j1, self.i0:self.i1]
    def pn(self):    return self._pn[self.j0:self.j1, self.i0:self.i1]
    def maskr(self): return self._maskr[self.j0:self.j1, self.i0:self.i1]
    def angle(self): return self._angle[self.j0:self.j1, self.i0:self.i1]
    def h(self):     return self._h[self.j0:self.j1, self.i0:self.i1]
    def hraw(self):  return self._hraw[self.j0:self.j1, self.i0:self.i1]
    def f(self):     return self._f[self.j0:self.j1, self.i0:self.i1]

    def idata(self):
        return np.nonzero(self.maskr().ravel() == 1.)[0]

    def imask(self):
        return np.nonzero(self.maskr().ravel() == 0.)[0]


    def _uvpmask(self):
        '''
        Get mask at u, v, psi points
        '''
        try:
            self._umask = self.read_nc('mask_u')
        except:
            #Mp, Lp = self.maskr().shape
            #print 'Mp',Mp,'  Lp',Lp
            #Mp -= 1
            #Lp -= 1
            #M = Mp - 1
            #L = Lp - 1
            self._umask = self.maskr()[:, :-1] * self.maskr()[:, 1:]
            self._vmask = self.maskr()[:-1]   * self.maskr()[1:]
            self._pmask = self._umask[:-1] * self._umask[1:]
        else:
            self._vmask = self.read_nc('mask_v')
            self._pmask = self.read_nc('mask_psi')
        return self


    def umask(self):
        return self._umask
        # Not sure about all below (29/12/2017) BUT indices needed
        # for tiled grids...
        # added '-1' 1/9/2016 cos problem in py_mercator_ini line ~385
        '''try:
            return self._umask[self.j0:self.j1, self.i0:self.i1-1]
        except:
            return self._umask[self.j0:self.j1, self.i0:-2]'''


    def vmask(self):
        return self._vmask
        # Not sure about all below (29/12/2017)
        # added '-1' 1/9/2016 cos problem in py_mercator_ini line ~385
        '''try:
            return self._vmask[self.j0:self.j1-1, self.i0:self.i1]
        except:
            return self._vmask[self.j0:-2, self.i0:self.i1]'''


    def pmask(self):
        print('fix me')
        return self._pmask


    def mask3d(self):
        '''
        3d stack of mask same size as N
        '''
        return np.tile(self.maskr(), (np.int(self.N), 1, 1))


    def umask3d(self):
        '''
        3d stack of umask same size as N
        '''
        return np.tile(self.umask(), (np.int(self.N), 1, 1))


    def vmask3d(self):
        '''
        3d stack of vmask same size as N
        '''
        return np.tile(self.vmask(), (np.int(self.N), 1, 1))


    def boundary(self):
        '''
        Return lon,lat of perimeter around a Croco grid
        '''
        lon = np.hstack((self.lon()[0:, 0], self.lon()[-1, 1:-1],
                         self.lon()[-1::-1, -1], self.lon()[0, -2::-1]))
        lat = np.hstack((self.lat()[0:, 0], self.lat()[-1, 1:-1],
                         self.lat()[-1::-1, -1], self.lat()[0, -2::-1]))
        return lon, lat


    def VertCoordType(self):
        nc = netcdf.Dataset(self.grdfile, 'r')
        var = nc.VertCoordType
        nc.close()
        return var

    def title(self):
        nc = netcdf.Dataset(self.grdfile, 'r')
        var = nc.title
        nc.close()
        return var



    def _scoord2z(self, point_type, zeta, alpha, beta):
        """
        z = scoord2z(h, theta_s, theta_b, hc, N, point_type, scoord, zeta)
        scoord2z finds z at either rho or w points (positive up, zero at rest surface)
        h          = array of depths (e.g., from grd file)
        theta_s    = surface focusing parameter
        theta_b    = bottom focusing parameter
        hc         = critical depth
        N          = number of vertical rho-points
        point_type = 'r' or 'w'
        scoord     = 'new2008' :new scoord 2008, 'new2006' : new scoord 2006,
                      or 'old1994' for Song scoord
        zeta       = sea surface height
        message    = set to False if don't want message
        """
        def CSF(self, sc):
            '''
            Allows use of theta_b > 0 (July 2009)
            '''
            one64 = np.float64(1)
            if self.theta_s > 0.:
                csrf = ((one64 - np.cosh(self.theta_s * sc))
                           / (np.cosh(self.theta_s) - one64))
            else:
                csrf = -sc ** 2
            sc1 = csrf + one64
            if self.theta_b > 0.:
                Cs = ((np.exp(self.theta_b * sc1) - one64)
                    / (np.exp(self.theta_b) - one64) - one64)
            else:
                Cs = csrf
            return Cs
        #
        try:
            self.scoord
        except:
            self.scoord = 'new2008'
        # N = np.float64(self.N.copy())
        N = np.float64(self.N)
        cff1 = 1. / np.sinh(self.theta_s)
        cff2 = 0.5 / np.tanh(0.5 * self.theta_s)
        sc_w = (np.arange(N + 1, dtype=np.float64) - N) / N
        sc_r = ((np.arange(1, N + 1, dtype=np.float64)) - N - 0.5) / N
        
        #sc_w = np.arange(-1., 1. / N, 1. / N, dtype=np.float64)
        #sc_r = 0.5 * (sc_w[1:] + sc_w[:-1])
        
        if 'w' in point_type:
            sc = sc_w
            N += 1. # add a level
        else:
            sc = sc_r
        #Cs = (1. - self.theta_b) * cff1 * np.sinh(self.theta_s * sc)  \
                 #+ self.theta_b * (cff2 * np.tanh(self.theta_s * (sc + 0.5)) - 0.5)
        z  = np.empty((int(N),) + self.h().shape, dtype=np.float64)
        if self.scoord in 'new2008':
            Cs = CSF(self, sc)
        if self.scoord in 'new2006' or self.scoord in 'new2008':
            hinv = 1. / (self.h() + self.hc)
            cff = (self.hc * sc).squeeze()
            cff1 = (Cs).squeeze()
            for k in np.arange(N, dtype=int):
                z[k] = zeta + (zeta + self.h()) * (cff[k] + cff1[k] * self.h()) * hinv
        elif self.scoord in 'old1994':
            hinv = 1. / self.h()
            cff  = (self.hc * (sc - Cs)).squeeze()
            cff1 = Cs.squeeze()
            cff2 = (sc + 1).squeeze()
            for k in np.arange(N) + 1:
                z0      = cff[k-1] + cff1[k-1] * self.h()
                z[k-1, :] = z0 + zeta * (1. + z0 * hinv)
        else:
            raise Exception("Unknown scoord, should be 'new2008' or 'old1994'")
        if self.sc_r is None:
            self.sc_r = sc_r
        return z.squeeze(), np.float32(Cs)


    def scoord2z_r(self, zeta=0., alpha=0., beta=1.):
        '''
        Depths at vertical rho points
        '''
        return self._scoord2z('r', zeta=zeta, alpha=alpha, beta=beta)[0]


    def Cs_r(self, zeta=0., alpha=0., beta=1.):
        '''
        S-coordinate stretching curves at rho points
        '''
        return self._scoord2z('r', zeta=zeta, alpha=alpha, beta=beta)[1]


    def scoord2z_w(self, zeta=0., alpha=0., beta=1.):
        '''
        Depths at vertical w points
        '''
        return self._scoord2z('w', zeta=zeta, alpha=alpha, beta=beta)[0]


    def Cs_w(self, zeta=0., alpha=0., beta=1.):
        '''
        S-coordinate stretching curves at w points
        '''
        return self._scoord2z('w', zeta=zeta, alpha=alpha, beta=beta)[1]

    def _set_dz_rho_points(self, zeta=0., alpha=0., beta=1):
        """
        Set depths of sigma layers at rho points, 3d matrix.
        """
        dz = self._scoord2z('w', zeta=zeta, alpha=alpha, beta=beta)[0]
        self._dz_rho_points = dz[1:] - dz[:-1]


    def scoord2dz(self, zeta=0., alpha=0., beta=1.):
        """
        dz at rho points, 3d matrix, depths of sigma layers
        """
        dz = self._scoord2z('w', zeta=zeta, alpha=alpha, beta=beta)[0]
        return dz[1:] - dz[:-1]

    def scoord2dz_u(self, zeta=0., alpha=0., beta=1.):
        '''
        dz at u points, 3d matrix, depths of sigma layers
        '''
        dz = self.scoord2dz(zeta=0., alpha=0., beta=1.)
        return self.rho2u_3d(dz)

    def scoord2dz_v(self, zeta=0., alpha=0., beta=1.):
        '''
        dz at v points, 3d matrix, depths of sigma layers
        '''
        dz = self.scoord2dz(zeta=0., alpha=0., beta=1.)
        return self.rho2v_3d(dz)



    # def get_depths(self,fname,tindex,type):

    #     zeta=0.*self.h

    #     # open history file
    #     #
    #     if os.path.isfile(fname):
    #       nc=Dataset(fname, 'r')
    #       ncvars = nc.variables.keys() 
    #       if "zeta" in ncvars:
    #         zeta=np.squeeze(nc.variables['zeta'][tindex,:,:])
    #       nc.close()

    #     vtype=type
    #     if (type=='u')|(type=='v'):
    #       vtype='r'
    #     z=self.zlevs(zeta,vtype)
    #     if type=='u':
    #       z=rho2u_3d(z)
    #     if type=='v':
    #       z=rho2v_3d(z)
    #     return z



    # def zlevs(self,zeta=0,type='r'):
    #   ################################################################
    #   #
    #   #  function z = zlevs(h,zeta,theta_s,theta_b,hc,N,type,vtransform)
    #   #
    #   #  this function compute the depth of rho or w points for ROMS
    #   #
    #   #  On Input:
    #   #
    #   #    type    'r': rho point 'w': w point 
    #   #    vtransform  1=> old v transform (Song, 1994) 
    #   #                2=> new v transform (Shcheptekin, 2006)
    #   #  On Output:
    #   #
    #   #    z       Depths (m) of RHO- or W-points (3D matrix).
    #   # 
    #   ################################################################


    #     #
    #     # Create S-coordinate system: based on model topography h(i,j),
    #     # fast-time-averaged free-surface field and vertical coordinate
    #     # transformation metrics compute evolving depths of of the three-
    #     # dimensional model grid. Also adjust zeta for dry cells.
    #     # 
    #     h=np.where(self.h == 0., 1.e-2, self.h)  
    #     Dcrit=0.01   # min water depth in dry cells
    #     mask = np.where(zeta<(Dcrit-h))
    #     zeta[mask]=Dcrit-h[mask]
    #     #
    #     hinv=1./h
    #     z=np.zeros((self.N,self.M,self.L))
    #     # if self.Vtransform == 2 :
    #     if type=='w':
    #         cff1=np.squeeze(self.Cs_w)
    #         cff2=self.sc_w+1
    #         sc=self.sc_w
    #     else:
    #         cff1=np.squeeze(self.Cs_r)
    #         cff2=self.sc_r+1
    #         sc=self.sc_r
    #     h2=(h+self.hc)
    #     cff=np.squeeze(self.hc*sc)
    #     h2inv=1./h2
    #     for k in range(0,self.N):
    #         z0=cff[k]+cff1[k]*h
    #         z[k,:,:]=z0*h/(h2) + zeta*(1.+z0*h2inv)
    #     # else:
    #     #     cff1=self.Cs
    #     #     cff2=self.sc+1
    #     #     cff=self.hc*(self.sc-self.Cs)
    #     #     cff2=self.sc+1
    #     #     for k in range(0,self.N):
    #     #         z0=cff[k]+cff1[k]*h
    #     #         z[k,:,:]=z0+zeta*(1.+z0*hinv)


    #     return z

    def zslice(self,var,mask,z,depth,findlev=False):
        """
        #
        #
        # This function interpolate a 3D variable on a horizontal level of constant
        # depth
        #
        # On Input:  
        # 
        #    var     Variable to process (3D matrix).
        #    z       Depths (m) of RHO- or W-points (3D matrix).
        #    depth   Slice depth (scalar meters, negative).
        # 
        # On Output: 
        #
        #    vnew    Horizontal slice (2D matrix). 
        #
        #
        """
        [N,Mp,Lp]=z.shape

        #
        # Find the grid position of the nearest vertical levels
        #
        a=np.where(z<=depth,1,0)
        levs=np.squeeze(np.sum(a,axis=0)) - 1
        levs = np.where(levs==N-1,N-2,levs)
        levs = np.where(levs==-1,0,levs)
        minlev = np.min(levs)
        maxlev = np.max(levs)
        if findlev==True:
            return minlev,maxlev

        # if maxlev-minlev==0:
        #     print("Not enough points")
        #     return 

        # Do the interpolation
        z1 = np.zeros_like(z[0,:,:])
        z2 = np.zeros_like(z[0,:,:])
        v1 = np.zeros_like(z[0,:,:])
        v2 = np.zeros_like(z[0,:,:])

        for j in range(Mp):
            for i in range(Lp):
                k = levs[j,i]
                z1[j,i] = z[k+1,j,i]
                z2[j,i] = z[k,j,i]
                v1[j,i] = var[k+1,j,i]
                v2[j,i] = var[k,j,i]
        zmask = np.where(z2>depth,np.nan,1)
        vnew=zmask*(((v1-v2)*depth+v2*z1-v1*z2)/(z1-z2))
        return vnew,minlev,maxlev


    def zslice2(self,var,mask,z,depth,findlev=False):
        """
        #
        #
        # This function interpolate a 3D variable on a horizontal level of constant
        # depth with scipy interp1d
        #
        # On Input:  
        # 
        #    var     Variable to process (3D matrix).
        #    z       Depths (m) of RHO- or W-points (3D matrix).
        #    depth   Slice depth (scalar meters, negative).
        # 
        # On Output: 
        #
        #    vnew    Horizontal slice (2D matrix). 
        #
        #
        """
        [N,Mp,Lp]=z.shape
        vnew = np.zeros_like(z[0,:,:])

        for j in range(Mp):
            for i in range (Lp):
                f = interpolate.interp1d(z[:,j,i], var[:,j,i],bounds_error=False)
                vnew[j,i] = f([depth])

        return vnew
        